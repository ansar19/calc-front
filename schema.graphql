schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

type Token {
  token: String!
}

type UserInfo {
  email: String!
  id: String!
  role: String!
  token: String!
}

"""
columns and relationships of "bank_accounts"
"""
type bank_accounts {
  """An object relationship"""
  bank: banks
  bank_id: uuid!

  """An object relationship"""
  company: companies
  company_id: uuid!
  created_at: timestamptz!

  """An object relationship"""
  currency: currencies
  currency_id: uuid!
  iban: String!
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "bank_accounts"
"""
type bank_accounts_aggregate {
  aggregate: bank_accounts_aggregate_fields
  nodes: [bank_accounts!]!
}

"""
aggregate fields of "bank_accounts"
"""
type bank_accounts_aggregate_fields {
  count(columns: [bank_accounts_select_column!], distinct: Boolean): Int
  max: bank_accounts_max_fields
  min: bank_accounts_min_fields
}

"""
order by aggregate values of table "bank_accounts"
"""
input bank_accounts_aggregate_order_by {
  count: order_by
  max: bank_accounts_max_order_by
  min: bank_accounts_min_order_by
}

"""
input type for inserting array relation for remote table "bank_accounts"
"""
input bank_accounts_arr_rel_insert_input {
  data: [bank_accounts_insert_input!]!
  on_conflict: bank_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "bank_accounts". All fields are combined with a logical 'AND'.
"""
input bank_accounts_bool_exp {
  _and: [bank_accounts_bool_exp]
  _not: bank_accounts_bool_exp
  _or: [bank_accounts_bool_exp]
  bank: banks_bool_exp
  bank_id: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: currencies_bool_exp
  currency_id: uuid_comparison_exp
  iban: String_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "bank_accounts"
"""
enum bank_accounts_constraint {
  """unique or primary key constraint"""
  bank_accounts_pkey
}

"""
input type for inserting data into table "bank_accounts"
"""
input bank_accounts_insert_input {
  bank: banks_obj_rel_insert_input
  bank_id: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  currency: currencies_obj_rel_insert_input
  currency_id: uuid
  iban: String
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type bank_accounts_max_fields {
  bank_id: uuid
  company_id: uuid
  created_at: timestamptz
  currency_id: uuid
  iban: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "bank_accounts"
"""
input bank_accounts_max_order_by {
  bank_id: order_by
  company_id: order_by
  created_at: order_by
  currency_id: order_by
  iban: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type bank_accounts_min_fields {
  bank_id: uuid
  company_id: uuid
  created_at: timestamptz
  currency_id: uuid
  iban: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "bank_accounts"
"""
input bank_accounts_min_order_by {
  bank_id: order_by
  company_id: order_by
  created_at: order_by
  currency_id: order_by
  iban: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "bank_accounts"
"""
type bank_accounts_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [bank_accounts!]!
}

"""
input type for inserting object relation for remote table "bank_accounts"
"""
input bank_accounts_obj_rel_insert_input {
  data: bank_accounts_insert_input!
  on_conflict: bank_accounts_on_conflict
}

"""
on conflict condition type for table "bank_accounts"
"""
input bank_accounts_on_conflict {
  constraint: bank_accounts_constraint!
  update_columns: [bank_accounts_update_column!]!
  where: bank_accounts_bool_exp
}

"""
ordering options when selecting data from "bank_accounts"
"""
input bank_accounts_order_by {
  bank: banks_order_by
  bank_id: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  currency: currencies_order_by
  currency_id: order_by
  iban: order_by
  id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "bank_accounts"
"""
input bank_accounts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "bank_accounts"
"""
enum bank_accounts_select_column {
  """column name"""
  bank_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  currency_id

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "bank_accounts"
"""
input bank_accounts_set_input {
  bank_id: uuid
  company_id: uuid
  created_at: timestamptz
  currency_id: uuid
  iban: String
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "bank_accounts"
"""
enum bank_accounts_update_column {
  """column name"""
  bank_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  currency_id

  """column name"""
  iban

  """column name"""
  id

  """column name"""
  updated_at
}

"""
columns and relationships of "banks"
"""
type banks {
  created_at: timestamptz
  id: uuid!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "banks"
"""
type banks_aggregate {
  aggregate: banks_aggregate_fields
  nodes: [banks!]!
}

"""
aggregate fields of "banks"
"""
type banks_aggregate_fields {
  count(columns: [banks_select_column!], distinct: Boolean): Int
  max: banks_max_fields
  min: banks_min_fields
}

"""
order by aggregate values of table "banks"
"""
input banks_aggregate_order_by {
  count: order_by
  max: banks_max_order_by
  min: banks_min_order_by
}

"""
input type for inserting array relation for remote table "banks"
"""
input banks_arr_rel_insert_input {
  data: [banks_insert_input!]!
  on_conflict: banks_on_conflict
}

"""
Boolean expression to filter rows from the table "banks". All fields are combined with a logical 'AND'.
"""
input banks_bool_exp {
  _and: [banks_bool_exp]
  _not: banks_bool_exp
  _or: [banks_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "banks"
"""
enum banks_constraint {
  """unique or primary key constraint"""
  banks_name_key

  """unique or primary key constraint"""
  banks_pkey
}

"""
input type for inserting data into table "banks"
"""
input banks_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type banks_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "banks"
"""
input banks_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type banks_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "banks"
"""
input banks_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "banks"
"""
type banks_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [banks!]!
}

"""
input type for inserting object relation for remote table "banks"
"""
input banks_obj_rel_insert_input {
  data: banks_insert_input!
  on_conflict: banks_on_conflict
}

"""
on conflict condition type for table "banks"
"""
input banks_on_conflict {
  constraint: banks_constraint!
  update_columns: [banks_update_column!]!
  where: banks_bool_exp
}

"""
ordering options when selecting data from "banks"
"""
input banks_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "banks"
"""
input banks_pk_columns_input {
  id: uuid!
}

"""
select columns of table "banks"
"""
enum banks_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "banks"
"""
input banks_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "banks"
"""
enum banks_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
columns and relationships of "cities"
"""
type cities {
  created_at: timestamptz!
  id: uuid!
  name: String!

  """An object relationship"""
  state: states!
  state_id: uuid!
  updated_at: timestamptz!
  zip: String
}

"""
aggregated selection of "cities"
"""
type cities_aggregate {
  aggregate: cities_aggregate_fields
  nodes: [cities!]!
}

"""
aggregate fields of "cities"
"""
type cities_aggregate_fields {
  count(columns: [cities_select_column!], distinct: Boolean): Int
  max: cities_max_fields
  min: cities_min_fields
}

"""
order by aggregate values of table "cities"
"""
input cities_aggregate_order_by {
  count: order_by
  max: cities_max_order_by
  min: cities_min_order_by
}

"""
input type for inserting array relation for remote table "cities"
"""
input cities_arr_rel_insert_input {
  data: [cities_insert_input!]!
  on_conflict: cities_on_conflict
}

"""
Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'.
"""
input cities_bool_exp {
  _and: [cities_bool_exp]
  _not: cities_bool_exp
  _or: [cities_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  state: states_bool_exp
  state_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  zip: String_comparison_exp
}

"""
unique or primary key constraints on table "cities"
"""
enum cities_constraint {
  """unique or primary key constraint"""
  cities_pkey
}

"""
input type for inserting data into table "cities"
"""
input cities_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  state: states_obj_rel_insert_input
  state_id: uuid
  updated_at: timestamptz
  zip: String
}

"""aggregate max on columns"""
type cities_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  state_id: uuid
  updated_at: timestamptz
  zip: String
}

"""
order by max() on columns of table "cities"
"""
input cities_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  state_id: order_by
  updated_at: order_by
  zip: order_by
}

"""aggregate min on columns"""
type cities_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  state_id: uuid
  updated_at: timestamptz
  zip: String
}

"""
order by min() on columns of table "cities"
"""
input cities_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  state_id: order_by
  updated_at: order_by
  zip: order_by
}

"""
response of any mutation on the table "cities"
"""
type cities_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [cities!]!
}

"""
input type for inserting object relation for remote table "cities"
"""
input cities_obj_rel_insert_input {
  data: cities_insert_input!
  on_conflict: cities_on_conflict
}

"""
on conflict condition type for table "cities"
"""
input cities_on_conflict {
  constraint: cities_constraint!
  update_columns: [cities_update_column!]!
  where: cities_bool_exp
}

"""
ordering options when selecting data from "cities"
"""
input cities_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  state: states_order_by
  state_id: order_by
  updated_at: order_by
  zip: order_by
}

"""
primary key columns input for table: "cities"
"""
input cities_pk_columns_input {
  id: uuid!
}

"""
select columns of table "cities"
"""
enum cities_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  state_id

  """column name"""
  updated_at

  """column name"""
  zip
}

"""
input type for updating data in table "cities"
"""
input cities_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  state_id: uuid
  updated_at: timestamptz
  zip: String
}

"""
update columns of table "cities"
"""
enum cities_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  state_id

  """column name"""
  updated_at

  """column name"""
  zip
}

"""
columns and relationships of "companies"
"""
type companies {
  """An array relationship"""
  bank_accounts(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): [bank_accounts!]!

  """An aggregated array relationship"""
  bank_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): bank_accounts_aggregate!

  """An object relationship"""
  company_actual_address: company_addresses
  company_actual_address_id: uuid
  company_description: String!
  company_email: String!

  """An object relationship"""
  company_head: employees
  company_head_employee_id: uuid

  """An object relationship"""
  company_legal_address: company_addresses
  company_legal_address_id: uuid
  company_name: String!
  company_phone: String!

  """An object relationship"""
  company_type: company_types!
  company_type_id: uuid!
  created_at: timestamptz
  id: uuid!
  iin_bin: String!
  updated_at: timestamptz

  """An array relationship"""
  worksites(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): [worksites!]!

  """An aggregated array relationship"""
  worksites_aggregate(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): worksites_aggregate!
}

"""
aggregated selection of "companies"
"""
type companies_aggregate {
  aggregate: companies_aggregate_fields
  nodes: [companies!]!
}

"""
aggregate fields of "companies"
"""
type companies_aggregate_fields {
  count(columns: [companies_select_column!], distinct: Boolean): Int
  max: companies_max_fields
  min: companies_min_fields
}

"""
order by aggregate values of table "companies"
"""
input companies_aggregate_order_by {
  count: order_by
  max: companies_max_order_by
  min: companies_min_order_by
}

"""
input type for inserting array relation for remote table "companies"
"""
input companies_arr_rel_insert_input {
  data: [companies_insert_input!]!
  on_conflict: companies_on_conflict
}

"""
Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'.
"""
input companies_bool_exp {
  _and: [companies_bool_exp]
  _not: companies_bool_exp
  _or: [companies_bool_exp]
  bank_accounts: bank_accounts_bool_exp
  company_actual_address: company_addresses_bool_exp
  company_actual_address_id: uuid_comparison_exp
  company_description: String_comparison_exp
  company_email: String_comparison_exp
  company_head: employees_bool_exp
  company_head_employee_id: uuid_comparison_exp
  company_legal_address: company_addresses_bool_exp
  company_legal_address_id: uuid_comparison_exp
  company_name: String_comparison_exp
  company_phone: String_comparison_exp
  company_type: company_types_bool_exp
  company_type_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  iin_bin: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  worksites: worksites_bool_exp
}

"""
unique or primary key constraints on table "companies"
"""
enum companies_constraint {
  """unique or primary key constraint"""
  companies_pkey
}

"""
input type for inserting data into table "companies"
"""
input companies_insert_input {
  bank_accounts: bank_accounts_arr_rel_insert_input
  company_actual_address: company_addresses_obj_rel_insert_input
  company_actual_address_id: uuid
  company_description: String
  company_email: String
  company_head: employees_obj_rel_insert_input
  company_head_employee_id: uuid
  company_legal_address: company_addresses_obj_rel_insert_input
  company_legal_address_id: uuid
  company_name: String
  company_phone: String
  company_type: company_types_obj_rel_insert_input
  company_type_id: uuid
  created_at: timestamptz
  id: uuid
  iin_bin: String
  updated_at: timestamptz
  worksites: worksites_arr_rel_insert_input
}

"""aggregate max on columns"""
type companies_max_fields {
  company_actual_address_id: uuid
  company_description: String
  company_email: String
  company_head_employee_id: uuid
  company_legal_address_id: uuid
  company_name: String
  company_phone: String
  company_type_id: uuid
  created_at: timestamptz
  id: uuid
  iin_bin: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "companies"
"""
input companies_max_order_by {
  company_actual_address_id: order_by
  company_description: order_by
  company_email: order_by
  company_head_employee_id: order_by
  company_legal_address_id: order_by
  company_name: order_by
  company_phone: order_by
  company_type_id: order_by
  created_at: order_by
  id: order_by
  iin_bin: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type companies_min_fields {
  company_actual_address_id: uuid
  company_description: String
  company_email: String
  company_head_employee_id: uuid
  company_legal_address_id: uuid
  company_name: String
  company_phone: String
  company_type_id: uuid
  created_at: timestamptz
  id: uuid
  iin_bin: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "companies"
"""
input companies_min_order_by {
  company_actual_address_id: order_by
  company_description: order_by
  company_email: order_by
  company_head_employee_id: order_by
  company_legal_address_id: order_by
  company_name: order_by
  company_phone: order_by
  company_type_id: order_by
  created_at: order_by
  id: order_by
  iin_bin: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "companies"
"""
type companies_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [companies!]!
}

"""
input type for inserting object relation for remote table "companies"
"""
input companies_obj_rel_insert_input {
  data: companies_insert_input!
  on_conflict: companies_on_conflict
}

"""
on conflict condition type for table "companies"
"""
input companies_on_conflict {
  constraint: companies_constraint!
  update_columns: [companies_update_column!]!
  where: companies_bool_exp
}

"""
ordering options when selecting data from "companies"
"""
input companies_order_by {
  bank_accounts_aggregate: bank_accounts_aggregate_order_by
  company_actual_address: company_addresses_order_by
  company_actual_address_id: order_by
  company_description: order_by
  company_email: order_by
  company_head: employees_order_by
  company_head_employee_id: order_by
  company_legal_address: company_addresses_order_by
  company_legal_address_id: order_by
  company_name: order_by
  company_phone: order_by
  company_type: company_types_order_by
  company_type_id: order_by
  created_at: order_by
  id: order_by
  iin_bin: order_by
  updated_at: order_by
  worksites_aggregate: worksites_aggregate_order_by
}

"""
primary key columns input for table: "companies"
"""
input companies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "companies"
"""
enum companies_select_column {
  """column name"""
  company_actual_address_id

  """column name"""
  company_description

  """column name"""
  company_email

  """column name"""
  company_head_employee_id

  """column name"""
  company_legal_address_id

  """column name"""
  company_name

  """column name"""
  company_phone

  """column name"""
  company_type_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  iin_bin

  """column name"""
  updated_at
}

"""
input type for updating data in table "companies"
"""
input companies_set_input {
  company_actual_address_id: uuid
  company_description: String
  company_email: String
  company_head_employee_id: uuid
  company_legal_address_id: uuid
  company_name: String
  company_phone: String
  company_type_id: uuid
  created_at: timestamptz
  id: uuid
  iin_bin: String
  updated_at: timestamptz
}

"""
update columns of table "companies"
"""
enum companies_update_column {
  """column name"""
  company_actual_address_id

  """column name"""
  company_description

  """column name"""
  company_email

  """column name"""
  company_head_employee_id

  """column name"""
  company_legal_address_id

  """column name"""
  company_name

  """column name"""
  company_phone

  """column name"""
  company_type_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  iin_bin

  """column name"""
  updated_at
}

"""
columns and relationships of "company_addresses"
"""
type company_addresses {
  address: String!

  """An object relationship"""
  city: cities!
  city_id: uuid!
  comments: String
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!
  zip: String!
}

"""
aggregated selection of "company_addresses"
"""
type company_addresses_aggregate {
  aggregate: company_addresses_aggregate_fields
  nodes: [company_addresses!]!
}

"""
aggregate fields of "company_addresses"
"""
type company_addresses_aggregate_fields {
  count(columns: [company_addresses_select_column!], distinct: Boolean): Int
  max: company_addresses_max_fields
  min: company_addresses_min_fields
}

"""
order by aggregate values of table "company_addresses"
"""
input company_addresses_aggregate_order_by {
  count: order_by
  max: company_addresses_max_order_by
  min: company_addresses_min_order_by
}

"""
input type for inserting array relation for remote table "company_addresses"
"""
input company_addresses_arr_rel_insert_input {
  data: [company_addresses_insert_input!]!
  on_conflict: company_addresses_on_conflict
}

"""
Boolean expression to filter rows from the table "company_addresses". All fields are combined with a logical 'AND'.
"""
input company_addresses_bool_exp {
  _and: [company_addresses_bool_exp]
  _not: company_addresses_bool_exp
  _or: [company_addresses_bool_exp]
  address: String_comparison_exp
  city: cities_bool_exp
  city_id: uuid_comparison_exp
  comments: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  zip: String_comparison_exp
}

"""
unique or primary key constraints on table "company_addresses"
"""
enum company_addresses_constraint {
  """unique or primary key constraint"""
  company_addresses_pkey
}

"""
input type for inserting data into table "company_addresses"
"""
input company_addresses_insert_input {
  address: String
  city: cities_obj_rel_insert_input
  city_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  zip: String
}

"""aggregate max on columns"""
type company_addresses_max_fields {
  address: String
  city_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  zip: String
}

"""
order by max() on columns of table "company_addresses"
"""
input company_addresses_max_order_by {
  address: order_by
  city_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  zip: order_by
}

"""aggregate min on columns"""
type company_addresses_min_fields {
  address: String
  city_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  zip: String
}

"""
order by min() on columns of table "company_addresses"
"""
input company_addresses_min_order_by {
  address: order_by
  city_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  zip: order_by
}

"""
response of any mutation on the table "company_addresses"
"""
type company_addresses_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [company_addresses!]!
}

"""
input type for inserting object relation for remote table "company_addresses"
"""
input company_addresses_obj_rel_insert_input {
  data: company_addresses_insert_input!
  on_conflict: company_addresses_on_conflict
}

"""
on conflict condition type for table "company_addresses"
"""
input company_addresses_on_conflict {
  constraint: company_addresses_constraint!
  update_columns: [company_addresses_update_column!]!
  where: company_addresses_bool_exp
}

"""
ordering options when selecting data from "company_addresses"
"""
input company_addresses_order_by {
  address: order_by
  city: cities_order_by
  city_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  zip: order_by
}

"""
primary key columns input for table: "company_addresses"
"""
input company_addresses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company_addresses"
"""
enum company_addresses_select_column {
  """column name"""
  address

  """column name"""
  city_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  zip
}

"""
input type for updating data in table "company_addresses"
"""
input company_addresses_set_input {
  address: String
  city_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  zip: String
}

"""
update columns of table "company_addresses"
"""
enum company_addresses_update_column {
  """column name"""
  address

  """column name"""
  city_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  zip
}

"""
columns and relationships of "company_departments"
"""
type company_departments {
  created_at: timestamptz!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregated array relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "company_departments"
"""
type company_departments_aggregate {
  aggregate: company_departments_aggregate_fields
  nodes: [company_departments!]!
}

"""
aggregate fields of "company_departments"
"""
type company_departments_aggregate_fields {
  count(columns: [company_departments_select_column!], distinct: Boolean): Int
  max: company_departments_max_fields
  min: company_departments_min_fields
}

"""
order by aggregate values of table "company_departments"
"""
input company_departments_aggregate_order_by {
  count: order_by
  max: company_departments_max_order_by
  min: company_departments_min_order_by
}

"""
input type for inserting array relation for remote table "company_departments"
"""
input company_departments_arr_rel_insert_input {
  data: [company_departments_insert_input!]!
  on_conflict: company_departments_on_conflict
}

"""
Boolean expression to filter rows from the table "company_departments". All fields are combined with a logical 'AND'.
"""
input company_departments_bool_exp {
  _and: [company_departments_bool_exp]
  _not: company_departments_bool_exp
  _or: [company_departments_bool_exp]
  created_at: timestamptz_comparison_exp
  employees: employees_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "company_departments"
"""
enum company_departments_constraint {
  """unique or primary key constraint"""
  company_departments_pkey
}

"""
input type for inserting data into table "company_departments"
"""
input company_departments_insert_input {
  created_at: timestamptz
  employees: employees_arr_rel_insert_input
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type company_departments_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "company_departments"
"""
input company_departments_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type company_departments_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "company_departments"
"""
input company_departments_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "company_departments"
"""
type company_departments_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [company_departments!]!
}

"""
input type for inserting object relation for remote table "company_departments"
"""
input company_departments_obj_rel_insert_input {
  data: company_departments_insert_input!
  on_conflict: company_departments_on_conflict
}

"""
on conflict condition type for table "company_departments"
"""
input company_departments_on_conflict {
  constraint: company_departments_constraint!
  update_columns: [company_departments_update_column!]!
  where: company_departments_bool_exp
}

"""
ordering options when selecting data from "company_departments"
"""
input company_departments_order_by {
  created_at: order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "company_departments"
"""
input company_departments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company_departments"
"""
enum company_departments_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "company_departments"
"""
input company_departments_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "company_departments"
"""
enum company_departments_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
columns and relationships of "company_types"
"""
type company_types {
  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregated array relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!
  created_at: timestamptz
  id: uuid!
  name: String!
  short_name: String
  termin: String
  updated_at: timestamptz
}

"""
aggregated selection of "company_types"
"""
type company_types_aggregate {
  aggregate: company_types_aggregate_fields
  nodes: [company_types!]!
}

"""
aggregate fields of "company_types"
"""
type company_types_aggregate_fields {
  count(columns: [company_types_select_column!], distinct: Boolean): Int
  max: company_types_max_fields
  min: company_types_min_fields
}

"""
order by aggregate values of table "company_types"
"""
input company_types_aggregate_order_by {
  count: order_by
  max: company_types_max_order_by
  min: company_types_min_order_by
}

"""
input type for inserting array relation for remote table "company_types"
"""
input company_types_arr_rel_insert_input {
  data: [company_types_insert_input!]!
  on_conflict: company_types_on_conflict
}

"""
Boolean expression to filter rows from the table "company_types". All fields are combined with a logical 'AND'.
"""
input company_types_bool_exp {
  _and: [company_types_bool_exp]
  _not: company_types_bool_exp
  _or: [company_types_bool_exp]
  companies: companies_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  short_name: String_comparison_exp
  termin: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "company_types"
"""
enum company_types_constraint {
  """unique or primary key constraint"""
  company_types_pkey

  """unique or primary key constraint"""
  company_types_termin_key
}

"""
input type for inserting data into table "company_types"
"""
input company_types_insert_input {
  companies: companies_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  termin: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type company_types_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  termin: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "company_types"
"""
input company_types_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  termin: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type company_types_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  termin: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "company_types"
"""
input company_types_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  termin: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "company_types"
"""
type company_types_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [company_types!]!
}

"""
input type for inserting object relation for remote table "company_types"
"""
input company_types_obj_rel_insert_input {
  data: company_types_insert_input!
  on_conflict: company_types_on_conflict
}

"""
on conflict condition type for table "company_types"
"""
input company_types_on_conflict {
  constraint: company_types_constraint!
  update_columns: [company_types_update_column!]!
  where: company_types_bool_exp
}

"""
ordering options when selecting data from "company_types"
"""
input company_types_order_by {
  companies_aggregate: companies_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  termin: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "company_types"
"""
input company_types_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company_types"
"""
enum company_types_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  termin

  """column name"""
  updated_at
}

"""
input type for updating data in table "company_types"
"""
input company_types_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  termin: String
  updated_at: timestamptz
}

"""
update columns of table "company_types"
"""
enum company_types_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  termin

  """column name"""
  updated_at
}

"""
columns and relationships of "countries"
"""
type countries {
  created_at: timestamptz
  id: uuid!
  name: String!

  """An array relationship"""
  states(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): [states!]!

  """An aggregated array relationship"""
  states_aggregate(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): states_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "countries"
"""
type countries_aggregate {
  aggregate: countries_aggregate_fields
  nodes: [countries!]!
}

"""
aggregate fields of "countries"
"""
type countries_aggregate_fields {
  count(columns: [countries_select_column!], distinct: Boolean): Int
  max: countries_max_fields
  min: countries_min_fields
}

"""
order by aggregate values of table "countries"
"""
input countries_aggregate_order_by {
  count: order_by
  max: countries_max_order_by
  min: countries_min_order_by
}

"""
input type for inserting array relation for remote table "countries"
"""
input countries_arr_rel_insert_input {
  data: [countries_insert_input!]!
  on_conflict: countries_on_conflict
}

"""
Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
"""
input countries_bool_exp {
  _and: [countries_bool_exp]
  _not: countries_bool_exp
  _or: [countries_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  states: states_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "countries"
"""
enum countries_constraint {
  """unique or primary key constraint"""
  countries_name_key

  """unique or primary key constraint"""
  countries_pkey
}

"""
input type for inserting data into table "countries"
"""
input countries_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  states: states_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type countries_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "countries"
"""
input countries_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type countries_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "countries"
"""
input countries_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "countries"
"""
type countries_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [countries!]!
}

"""
input type for inserting object relation for remote table "countries"
"""
input countries_obj_rel_insert_input {
  data: countries_insert_input!
  on_conflict: countries_on_conflict
}

"""
on conflict condition type for table "countries"
"""
input countries_on_conflict {
  constraint: countries_constraint!
  update_columns: [countries_update_column!]!
  where: countries_bool_exp
}

"""
ordering options when selecting data from "countries"
"""
input countries_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  states_aggregate: states_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "countries"
"""
input countries_pk_columns_input {
  id: uuid!
}

"""
select columns of table "countries"
"""
enum countries_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "countries"
"""
input countries_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "countries"
"""
enum countries_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
columns and relationships of "currencies"
"""
type currencies {
  created_at: timestamptz!
  id: uuid!
  name: String!
  short_name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "currencies"
"""
type currencies_aggregate {
  aggregate: currencies_aggregate_fields
  nodes: [currencies!]!
}

"""
aggregate fields of "currencies"
"""
type currencies_aggregate_fields {
  count(columns: [currencies_select_column!], distinct: Boolean): Int
  max: currencies_max_fields
  min: currencies_min_fields
}

"""
order by aggregate values of table "currencies"
"""
input currencies_aggregate_order_by {
  count: order_by
  max: currencies_max_order_by
  min: currencies_min_order_by
}

"""
input type for inserting array relation for remote table "currencies"
"""
input currencies_arr_rel_insert_input {
  data: [currencies_insert_input!]!
  on_conflict: currencies_on_conflict
}

"""
Boolean expression to filter rows from the table "currencies". All fields are combined with a logical 'AND'.
"""
input currencies_bool_exp {
  _and: [currencies_bool_exp]
  _not: currencies_bool_exp
  _or: [currencies_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "currencies"
"""
enum currencies_constraint {
  """unique or primary key constraint"""
  currencies_name_key

  """unique or primary key constraint"""
  currencies_pkey

  """unique or primary key constraint"""
  currencies_short_name_key
}

"""
input type for inserting data into table "currencies"
"""
input currencies_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type currencies_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "currencies"
"""
input currencies_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type currencies_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "currencies"
"""
input currencies_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "currencies"
"""
type currencies_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [currencies!]!
}

"""
input type for inserting object relation for remote table "currencies"
"""
input currencies_obj_rel_insert_input {
  data: currencies_insert_input!
  on_conflict: currencies_on_conflict
}

"""
on conflict condition type for table "currencies"
"""
input currencies_on_conflict {
  constraint: currencies_constraint!
  update_columns: [currencies_update_column!]!
  where: currencies_bool_exp
}

"""
ordering options when selecting data from "currencies"
"""
input currencies_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "currencies"
"""
input currencies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "currencies"
"""
enum currencies_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "currencies"
"""
input currencies_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
update columns of table "currencies"
"""
enum currencies_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

scalar date

"""
expression to compare columns of type date. All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "emission_sources"
"""
type emission_sources {
  created_at: timestamptz!
  description: String!
  facility_loc_id: uuid!

  """An object relationship"""
  facility_location: facility_locations

  """An array relationship"""
  filters(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): [filter_equipments!]!

  """An aggregated array relationship"""
  filters_aggregate(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): filter_equipments_aggregate!
  has_filter: Boolean!
  id: uuid!
  inventory_number: String!
  name: String!
  number: String
  organized: Boolean!
  product: String!

  """An array relationship"""
  release_sources(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): [release_sources!]!

  """An aggregated array relationship"""
  release_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): release_sources_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "emission_sources"
"""
type emission_sources_aggregate {
  aggregate: emission_sources_aggregate_fields
  nodes: [emission_sources!]!
}

"""
aggregate fields of "emission_sources"
"""
type emission_sources_aggregate_fields {
  count(columns: [emission_sources_select_column!], distinct: Boolean): Int
  max: emission_sources_max_fields
  min: emission_sources_min_fields
}

"""
order by aggregate values of table "emission_sources"
"""
input emission_sources_aggregate_order_by {
  count: order_by
  max: emission_sources_max_order_by
  min: emission_sources_min_order_by
}

"""
input type for inserting array relation for remote table "emission_sources"
"""
input emission_sources_arr_rel_insert_input {
  data: [emission_sources_insert_input!]!
  on_conflict: emission_sources_on_conflict
}

"""
Boolean expression to filter rows from the table "emission_sources". All fields are combined with a logical 'AND'.
"""
input emission_sources_bool_exp {
  _and: [emission_sources_bool_exp]
  _not: emission_sources_bool_exp
  _or: [emission_sources_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  facility_loc_id: uuid_comparison_exp
  facility_location: facility_locations_bool_exp
  filters: filter_equipments_bool_exp
  has_filter: Boolean_comparison_exp
  id: uuid_comparison_exp
  inventory_number: String_comparison_exp
  name: String_comparison_exp
  number: String_comparison_exp
  organized: Boolean_comparison_exp
  product: String_comparison_exp
  release_sources: release_sources_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "emission_sources"
"""
enum emission_sources_constraint {
  """unique or primary key constraint"""
  emission_sources_pkey
}

"""
input type for inserting data into table "emission_sources"
"""
input emission_sources_insert_input {
  created_at: timestamptz
  description: String
  facility_loc_id: uuid
  facility_location: facility_locations_obj_rel_insert_input
  filters: filter_equipments_arr_rel_insert_input
  has_filter: Boolean
  id: uuid
  inventory_number: String
  name: String
  number: String
  organized: Boolean
  product: String
  release_sources: release_sources_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type emission_sources_max_fields {
  created_at: timestamptz
  description: String
  facility_loc_id: uuid
  id: uuid
  inventory_number: String
  name: String
  number: String
  product: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "emission_sources"
"""
input emission_sources_max_order_by {
  created_at: order_by
  description: order_by
  facility_loc_id: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  product: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type emission_sources_min_fields {
  created_at: timestamptz
  description: String
  facility_loc_id: uuid
  id: uuid
  inventory_number: String
  name: String
  number: String
  product: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "emission_sources"
"""
input emission_sources_min_order_by {
  created_at: order_by
  description: order_by
  facility_loc_id: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  product: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "emission_sources"
"""
type emission_sources_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [emission_sources!]!
}

"""
input type for inserting object relation for remote table "emission_sources"
"""
input emission_sources_obj_rel_insert_input {
  data: emission_sources_insert_input!
  on_conflict: emission_sources_on_conflict
}

"""
on conflict condition type for table "emission_sources"
"""
input emission_sources_on_conflict {
  constraint: emission_sources_constraint!
  update_columns: [emission_sources_update_column!]!
  where: emission_sources_bool_exp
}

"""
ordering options when selecting data from "emission_sources"
"""
input emission_sources_order_by {
  created_at: order_by
  description: order_by
  facility_loc_id: order_by
  facility_location: facility_locations_order_by
  filters_aggregate: filter_equipments_aggregate_order_by
  has_filter: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  organized: order_by
  product: order_by
  release_sources_aggregate: release_sources_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "emission_sources"
"""
input emission_sources_pk_columns_input {
  id: uuid!
}

"""
select columns of table "emission_sources"
"""
enum emission_sources_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  facility_loc_id

  """column name"""
  has_filter

  """column name"""
  id

  """column name"""
  inventory_number

  """column name"""
  name

  """column name"""
  number

  """column name"""
  organized

  """column name"""
  product

  """column name"""
  updated_at
}

"""
input type for updating data in table "emission_sources"
"""
input emission_sources_set_input {
  created_at: timestamptz
  description: String
  facility_loc_id: uuid
  has_filter: Boolean
  id: uuid
  inventory_number: String
  name: String
  number: String
  organized: Boolean
  product: String
  updated_at: timestamptz
}

"""
update columns of table "emission_sources"
"""
enum emission_sources_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  facility_loc_id

  """column name"""
  has_filter

  """column name"""
  id

  """column name"""
  inventory_number

  """column name"""
  name

  """column name"""
  number

  """column name"""
  organized

  """column name"""
  product

  """column name"""
  updated_at
}

"""
columns and relationships of "employee_positions"
"""
type employee_positions {
  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregated array relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: String!
}

"""
aggregated selection of "employee_positions"
"""
type employee_positions_aggregate {
  aggregate: employee_positions_aggregate_fields
  nodes: [employee_positions!]!
}

"""
aggregate fields of "employee_positions"
"""
type employee_positions_aggregate_fields {
  count(columns: [employee_positions_select_column!], distinct: Boolean): Int
  max: employee_positions_max_fields
  min: employee_positions_min_fields
}

"""
order by aggregate values of table "employee_positions"
"""
input employee_positions_aggregate_order_by {
  count: order_by
  max: employee_positions_max_order_by
  min: employee_positions_min_order_by
}

"""
input type for inserting array relation for remote table "employee_positions"
"""
input employee_positions_arr_rel_insert_input {
  data: [employee_positions_insert_input!]!
  on_conflict: employee_positions_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_positions". All fields are combined with a logical 'AND'.
"""
input employee_positions_bool_exp {
  _and: [employee_positions_bool_exp]
  _not: employee_positions_bool_exp
  _or: [employee_positions_bool_exp]
  employees: employees_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "employee_positions"
"""
enum employee_positions_constraint {
  """unique or primary key constraint"""
  positions_pkey
}

"""
input type for inserting data into table "employee_positions"
"""
input employee_positions_insert_input {
  employees: employees_arr_rel_insert_input
  id: uuid
  name: String
}

"""aggregate max on columns"""
type employee_positions_max_fields {
  id: uuid
  name: String
}

"""
order by max() on columns of table "employee_positions"
"""
input employee_positions_max_order_by {
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type employee_positions_min_fields {
  id: uuid
  name: String
}

"""
order by min() on columns of table "employee_positions"
"""
input employee_positions_min_order_by {
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "employee_positions"
"""
type employee_positions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [employee_positions!]!
}

"""
input type for inserting object relation for remote table "employee_positions"
"""
input employee_positions_obj_rel_insert_input {
  data: employee_positions_insert_input!
  on_conflict: employee_positions_on_conflict
}

"""
on conflict condition type for table "employee_positions"
"""
input employee_positions_on_conflict {
  constraint: employee_positions_constraint!
  update_columns: [employee_positions_update_column!]!
  where: employee_positions_bool_exp
}

"""
ordering options when selecting data from "employee_positions"
"""
input employee_positions_order_by {
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
}

"""
primary key columns input for table: "employee_positions"
"""
input employee_positions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_positions"
"""
enum employee_positions_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "employee_positions"
"""
input employee_positions_set_input {
  id: uuid
  name: String
}

"""
update columns of table "employee_positions"
"""
enum employee_positions_update_column {
  """column name"""
  id

  """column name"""
  name
}

"""
columns and relationships of "employees"
"""
type employees {
  created_at: timestamptz!

  """An object relationship"""
  department: company_departments
  department_id: uuid
  email: String
  first_name: String!
  id: uuid!
  last_name: String!
  middle_name: String!
  phone: String

  """An object relationship"""
  position: employee_positions!
  position_id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "employees"
"""
type employees_aggregate {
  aggregate: employees_aggregate_fields
  nodes: [employees!]!
}

"""
aggregate fields of "employees"
"""
type employees_aggregate_fields {
  avg: employees_avg_fields
  count(columns: [employees_select_column!], distinct: Boolean): Int
  max: employees_max_fields
  min: employees_min_fields
  stddev: employees_stddev_fields
  stddev_pop: employees_stddev_pop_fields
  stddev_samp: employees_stddev_samp_fields
  sum: employees_sum_fields
  var_pop: employees_var_pop_fields
  var_samp: employees_var_samp_fields
  variance: employees_variance_fields
}

"""
order by aggregate values of table "employees"
"""
input employees_aggregate_order_by {
  avg: employees_avg_order_by
  count: order_by
  max: employees_max_order_by
  min: employees_min_order_by
  stddev: employees_stddev_order_by
  stddev_pop: employees_stddev_pop_order_by
  stddev_samp: employees_stddev_samp_order_by
  sum: employees_sum_order_by
  var_pop: employees_var_pop_order_by
  var_samp: employees_var_samp_order_by
  variance: employees_variance_order_by
}

"""
input type for inserting array relation for remote table "employees"
"""
input employees_arr_rel_insert_input {
  data: [employees_insert_input!]!
  on_conflict: employees_on_conflict
}

"""aggregate avg on columns"""
type employees_avg_fields {
  user_id: Float
}

"""
order by avg() on columns of table "employees"
"""
input employees_avg_order_by {
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'.
"""
input employees_bool_exp {
  _and: [employees_bool_exp]
  _not: employees_bool_exp
  _or: [employees_bool_exp]
  created_at: timestamptz_comparison_exp
  department: company_departments_bool_exp
  department_id: uuid_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  middle_name: String_comparison_exp
  phone: String_comparison_exp
  position: employee_positions_bool_exp
  position_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "employees"
"""
enum employees_constraint {
  """unique or primary key constraint"""
  employees_pkey
}

"""
input type for incrementing integer column in table "employees"
"""
input employees_inc_input {
  user_id: Int
}

"""
input type for inserting data into table "employees"
"""
input employees_insert_input {
  created_at: timestamptz
  department: company_departments_obj_rel_insert_input
  department_id: uuid
  email: String
  first_name: String
  id: uuid
  last_name: String
  middle_name: String
  phone: String
  position: employee_positions_obj_rel_insert_input
  position_id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type employees_max_fields {
  created_at: timestamptz
  department_id: uuid
  email: String
  first_name: String
  id: uuid
  last_name: String
  middle_name: String
  phone: String
  position_id: uuid
  updated_at: timestamptz
  user_id: Int
}

"""
order by max() on columns of table "employees"
"""
input employees_max_order_by {
  created_at: order_by
  department_id: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  middle_name: order_by
  phone: order_by
  position_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type employees_min_fields {
  created_at: timestamptz
  department_id: uuid
  email: String
  first_name: String
  id: uuid
  last_name: String
  middle_name: String
  phone: String
  position_id: uuid
  updated_at: timestamptz
  user_id: Int
}

"""
order by min() on columns of table "employees"
"""
input employees_min_order_by {
  created_at: order_by
  department_id: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  middle_name: order_by
  phone: order_by
  position_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "employees"
"""
type employees_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [employees!]!
}

"""
input type for inserting object relation for remote table "employees"
"""
input employees_obj_rel_insert_input {
  data: employees_insert_input!
  on_conflict: employees_on_conflict
}

"""
on conflict condition type for table "employees"
"""
input employees_on_conflict {
  constraint: employees_constraint!
  update_columns: [employees_update_column!]!
  where: employees_bool_exp
}

"""
ordering options when selecting data from "employees"
"""
input employees_order_by {
  created_at: order_by
  department: company_departments_order_by
  department_id: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  middle_name: order_by
  phone: order_by
  position: employee_positions_order_by
  position_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""
primary key columns input for table: "employees"
"""
input employees_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employees"
"""
enum employees_select_column {
  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  middle_name

  """column name"""
  phone

  """column name"""
  position_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "employees"
"""
input employees_set_input {
  created_at: timestamptz
  department_id: uuid
  email: String
  first_name: String
  id: uuid
  last_name: String
  middle_name: String
  phone: String
  position_id: uuid
  updated_at: timestamptz
  user_id: Int
}

"""aggregate stddev on columns"""
type employees_stddev_fields {
  user_id: Float
}

"""
order by stddev() on columns of table "employees"
"""
input employees_stddev_order_by {
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type employees_stddev_pop_fields {
  user_id: Float
}

"""
order by stddev_pop() on columns of table "employees"
"""
input employees_stddev_pop_order_by {
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type employees_stddev_samp_fields {
  user_id: Float
}

"""
order by stddev_samp() on columns of table "employees"
"""
input employees_stddev_samp_order_by {
  user_id: order_by
}

"""aggregate sum on columns"""
type employees_sum_fields {
  user_id: Int
}

"""
order by sum() on columns of table "employees"
"""
input employees_sum_order_by {
  user_id: order_by
}

"""
update columns of table "employees"
"""
enum employees_update_column {
  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  middle_name

  """column name"""
  phone

  """column name"""
  position_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type employees_var_pop_fields {
  user_id: Float
}

"""
order by var_pop() on columns of table "employees"
"""
input employees_var_pop_order_by {
  user_id: order_by
}

"""aggregate var_samp on columns"""
type employees_var_samp_fields {
  user_id: Float
}

"""
order by var_samp() on columns of table "employees"
"""
input employees_var_samp_order_by {
  user_id: order_by
}

"""aggregate variance on columns"""
type employees_variance_fields {
  user_id: Float
}

"""
order by variance() on columns of table "employees"
"""
input employees_variance_order_by {
  user_id: order_by
}

"""
columns and relationships of "facilities"
"""
type facilities {
  created_at: timestamptz!

  """An array relationship"""
  facility_locations(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): [facility_locations!]!

  """An aggregated array relationship"""
  facility_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): facility_locations_aggregate!
  id: uuid!
  name: String!
  updated_at: timestamptz!
  woriksite_id: uuid!

  """An object relationship"""
  worksite: worksites
}

"""
aggregated selection of "facilities"
"""
type facilities_aggregate {
  aggregate: facilities_aggregate_fields
  nodes: [facilities!]!
}

"""
aggregate fields of "facilities"
"""
type facilities_aggregate_fields {
  count(columns: [facilities_select_column!], distinct: Boolean): Int
  max: facilities_max_fields
  min: facilities_min_fields
}

"""
order by aggregate values of table "facilities"
"""
input facilities_aggregate_order_by {
  count: order_by
  max: facilities_max_order_by
  min: facilities_min_order_by
}

"""
input type for inserting array relation for remote table "facilities"
"""
input facilities_arr_rel_insert_input {
  data: [facilities_insert_input!]!
  on_conflict: facilities_on_conflict
}

"""
Boolean expression to filter rows from the table "facilities". All fields are combined with a logical 'AND'.
"""
input facilities_bool_exp {
  _and: [facilities_bool_exp]
  _not: facilities_bool_exp
  _or: [facilities_bool_exp]
  created_at: timestamptz_comparison_exp
  facility_locations: facility_locations_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  woriksite_id: uuid_comparison_exp
  worksite: worksites_bool_exp
}

"""
unique or primary key constraints on table "facilities"
"""
enum facilities_constraint {
  """unique or primary key constraint"""
  facilities_pkey
}

"""
input type for inserting data into table "facilities"
"""
input facilities_insert_input {
  created_at: timestamptz
  facility_locations: facility_locations_arr_rel_insert_input
  id: uuid
  name: String
  updated_at: timestamptz
  woriksite_id: uuid
  worksite: worksites_obj_rel_insert_input
}

"""aggregate max on columns"""
type facilities_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  woriksite_id: uuid
}

"""
order by max() on columns of table "facilities"
"""
input facilities_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  woriksite_id: order_by
}

"""aggregate min on columns"""
type facilities_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  woriksite_id: uuid
}

"""
order by min() on columns of table "facilities"
"""
input facilities_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  woriksite_id: order_by
}

"""
response of any mutation on the table "facilities"
"""
type facilities_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [facilities!]!
}

"""
input type for inserting object relation for remote table "facilities"
"""
input facilities_obj_rel_insert_input {
  data: facilities_insert_input!
  on_conflict: facilities_on_conflict
}

"""
on conflict condition type for table "facilities"
"""
input facilities_on_conflict {
  constraint: facilities_constraint!
  update_columns: [facilities_update_column!]!
  where: facilities_bool_exp
}

"""
ordering options when selecting data from "facilities"
"""
input facilities_order_by {
  created_at: order_by
  facility_locations_aggregate: facility_locations_aggregate_order_by
  id: order_by
  name: order_by
  updated_at: order_by
  woriksite_id: order_by
  worksite: worksites_order_by
}

"""
primary key columns input for table: "facilities"
"""
input facilities_pk_columns_input {
  id: uuid!
}

"""
select columns of table "facilities"
"""
enum facilities_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  woriksite_id
}

"""
input type for updating data in table "facilities"
"""
input facilities_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  woriksite_id: uuid
}

"""
update columns of table "facilities"
"""
enum facilities_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  woriksite_id
}

"""
columns and relationships of "facility_locations"
"""
type facility_locations {
  created_at: timestamptz!

  """An array relationship"""
  emission_sources(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): [emission_sources!]!

  """An aggregated array relationship"""
  emission_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): emission_sources_aggregate!

  """An object relationship"""
  facility: facilities
  facility_id: uuid!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "facility_locations"
"""
type facility_locations_aggregate {
  aggregate: facility_locations_aggregate_fields
  nodes: [facility_locations!]!
}

"""
aggregate fields of "facility_locations"
"""
type facility_locations_aggregate_fields {
  count(columns: [facility_locations_select_column!], distinct: Boolean): Int
  max: facility_locations_max_fields
  min: facility_locations_min_fields
}

"""
order by aggregate values of table "facility_locations"
"""
input facility_locations_aggregate_order_by {
  count: order_by
  max: facility_locations_max_order_by
  min: facility_locations_min_order_by
}

"""
input type for inserting array relation for remote table "facility_locations"
"""
input facility_locations_arr_rel_insert_input {
  data: [facility_locations_insert_input!]!
  on_conflict: facility_locations_on_conflict
}

"""
Boolean expression to filter rows from the table "facility_locations". All fields are combined with a logical 'AND'.
"""
input facility_locations_bool_exp {
  _and: [facility_locations_bool_exp]
  _not: facility_locations_bool_exp
  _or: [facility_locations_bool_exp]
  created_at: timestamptz_comparison_exp
  emission_sources: emission_sources_bool_exp
  facility: facilities_bool_exp
  facility_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "facility_locations"
"""
enum facility_locations_constraint {
  """unique or primary key constraint"""
  facility_locations_pkey
}

"""
input type for inserting data into table "facility_locations"
"""
input facility_locations_insert_input {
  created_at: timestamptz
  emission_sources: emission_sources_arr_rel_insert_input
  facility: facilities_obj_rel_insert_input
  facility_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type facility_locations_max_fields {
  created_at: timestamptz
  facility_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "facility_locations"
"""
input facility_locations_max_order_by {
  created_at: order_by
  facility_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type facility_locations_min_fields {
  created_at: timestamptz
  facility_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "facility_locations"
"""
input facility_locations_min_order_by {
  created_at: order_by
  facility_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "facility_locations"
"""
type facility_locations_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [facility_locations!]!
}

"""
input type for inserting object relation for remote table "facility_locations"
"""
input facility_locations_obj_rel_insert_input {
  data: facility_locations_insert_input!
  on_conflict: facility_locations_on_conflict
}

"""
on conflict condition type for table "facility_locations"
"""
input facility_locations_on_conflict {
  constraint: facility_locations_constraint!
  update_columns: [facility_locations_update_column!]!
  where: facility_locations_bool_exp
}

"""
ordering options when selecting data from "facility_locations"
"""
input facility_locations_order_by {
  created_at: order_by
  emission_sources_aggregate: emission_sources_aggregate_order_by
  facility: facilities_order_by
  facility_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "facility_locations"
"""
input facility_locations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "facility_locations"
"""
enum facility_locations_select_column {
  """column name"""
  created_at

  """column name"""
  facility_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "facility_locations"
"""
input facility_locations_set_input {
  created_at: timestamptz
  facility_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "facility_locations"
"""
enum facility_locations_update_column {
  """column name"""
  created_at

  """column name"""
  facility_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
columns and relationships of "filter_equipments"
"""
type filter_equipments {
  created_at: timestamptz!
  description: String
  emission_src_id: uuid!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "filter_equipments"
"""
type filter_equipments_aggregate {
  aggregate: filter_equipments_aggregate_fields
  nodes: [filter_equipments!]!
}

"""
aggregate fields of "filter_equipments"
"""
type filter_equipments_aggregate_fields {
  count(columns: [filter_equipments_select_column!], distinct: Boolean): Int
  max: filter_equipments_max_fields
  min: filter_equipments_min_fields
}

"""
order by aggregate values of table "filter_equipments"
"""
input filter_equipments_aggregate_order_by {
  count: order_by
  max: filter_equipments_max_order_by
  min: filter_equipments_min_order_by
}

"""
input type for inserting array relation for remote table "filter_equipments"
"""
input filter_equipments_arr_rel_insert_input {
  data: [filter_equipments_insert_input!]!
  on_conflict: filter_equipments_on_conflict
}

"""
Boolean expression to filter rows from the table "filter_equipments". All fields are combined with a logical 'AND'.
"""
input filter_equipments_bool_exp {
  _and: [filter_equipments_bool_exp]
  _not: filter_equipments_bool_exp
  _or: [filter_equipments_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  emission_src_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "filter_equipments"
"""
enum filter_equipments_constraint {
  """unique or primary key constraint"""
  filter_equipments_pkey
}

"""
input type for inserting data into table "filter_equipments"
"""
input filter_equipments_insert_input {
  created_at: timestamptz
  description: String
  emission_src_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type filter_equipments_max_fields {
  created_at: timestamptz
  description: String
  emission_src_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "filter_equipments"
"""
input filter_equipments_max_order_by {
  created_at: order_by
  description: order_by
  emission_src_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type filter_equipments_min_fields {
  created_at: timestamptz
  description: String
  emission_src_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "filter_equipments"
"""
input filter_equipments_min_order_by {
  created_at: order_by
  description: order_by
  emission_src_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "filter_equipments"
"""
type filter_equipments_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [filter_equipments!]!
}

"""
input type for inserting object relation for remote table "filter_equipments"
"""
input filter_equipments_obj_rel_insert_input {
  data: filter_equipments_insert_input!
  on_conflict: filter_equipments_on_conflict
}

"""
on conflict condition type for table "filter_equipments"
"""
input filter_equipments_on_conflict {
  constraint: filter_equipments_constraint!
  update_columns: [filter_equipments_update_column!]!
  where: filter_equipments_bool_exp
}

"""
ordering options when selecting data from "filter_equipments"
"""
input filter_equipments_order_by {
  created_at: order_by
  description: order_by
  emission_src_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "filter_equipments"
"""
input filter_equipments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "filter_equipments"
"""
enum filter_equipments_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  emission_src_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "filter_equipments"
"""
input filter_equipments_set_input {
  created_at: timestamptz
  description: String
  emission_src_id: uuid
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "filter_equipments"
"""
enum filter_equipments_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  emission_src_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

scalar json

"""
expression to compare columns of type json. All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""
columns and relationships of "limit_permissions"
"""
type limit_permissions {
  end_date: date!
  id: uuid!
  number: String!
  release_source_id: uuid!
  start_date: date!
  t_year_limit: Int!
}

"""
aggregated selection of "limit_permissions"
"""
type limit_permissions_aggregate {
  aggregate: limit_permissions_aggregate_fields
  nodes: [limit_permissions!]!
}

"""
aggregate fields of "limit_permissions"
"""
type limit_permissions_aggregate_fields {
  avg: limit_permissions_avg_fields
  count(columns: [limit_permissions_select_column!], distinct: Boolean): Int
  max: limit_permissions_max_fields
  min: limit_permissions_min_fields
  stddev: limit_permissions_stddev_fields
  stddev_pop: limit_permissions_stddev_pop_fields
  stddev_samp: limit_permissions_stddev_samp_fields
  sum: limit_permissions_sum_fields
  var_pop: limit_permissions_var_pop_fields
  var_samp: limit_permissions_var_samp_fields
  variance: limit_permissions_variance_fields
}

"""
order by aggregate values of table "limit_permissions"
"""
input limit_permissions_aggregate_order_by {
  avg: limit_permissions_avg_order_by
  count: order_by
  max: limit_permissions_max_order_by
  min: limit_permissions_min_order_by
  stddev: limit_permissions_stddev_order_by
  stddev_pop: limit_permissions_stddev_pop_order_by
  stddev_samp: limit_permissions_stddev_samp_order_by
  sum: limit_permissions_sum_order_by
  var_pop: limit_permissions_var_pop_order_by
  var_samp: limit_permissions_var_samp_order_by
  variance: limit_permissions_variance_order_by
}

"""
input type for inserting array relation for remote table "limit_permissions"
"""
input limit_permissions_arr_rel_insert_input {
  data: [limit_permissions_insert_input!]!
  on_conflict: limit_permissions_on_conflict
}

"""aggregate avg on columns"""
type limit_permissions_avg_fields {
  t_year_limit: Float
}

"""
order by avg() on columns of table "limit_permissions"
"""
input limit_permissions_avg_order_by {
  t_year_limit: order_by
}

"""
Boolean expression to filter rows from the table "limit_permissions". All fields are combined with a logical 'AND'.
"""
input limit_permissions_bool_exp {
  _and: [limit_permissions_bool_exp]
  _not: limit_permissions_bool_exp
  _or: [limit_permissions_bool_exp]
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  number: String_comparison_exp
  release_source_id: uuid_comparison_exp
  start_date: date_comparison_exp
  t_year_limit: Int_comparison_exp
}

"""
unique or primary key constraints on table "limit_permissions"
"""
enum limit_permissions_constraint {
  """unique or primary key constraint"""
  limit_permissions_pkey
}

"""
input type for incrementing integer column in table "limit_permissions"
"""
input limit_permissions_inc_input {
  t_year_limit: Int
}

"""
input type for inserting data into table "limit_permissions"
"""
input limit_permissions_insert_input {
  end_date: date
  id: uuid
  number: String
  release_source_id: uuid
  start_date: date
  t_year_limit: Int
}

"""aggregate max on columns"""
type limit_permissions_max_fields {
  end_date: date
  id: uuid
  number: String
  release_source_id: uuid
  start_date: date
  t_year_limit: Int
}

"""
order by max() on columns of table "limit_permissions"
"""
input limit_permissions_max_order_by {
  end_date: order_by
  id: order_by
  number: order_by
  release_source_id: order_by
  start_date: order_by
  t_year_limit: order_by
}

"""aggregate min on columns"""
type limit_permissions_min_fields {
  end_date: date
  id: uuid
  number: String
  release_source_id: uuid
  start_date: date
  t_year_limit: Int
}

"""
order by min() on columns of table "limit_permissions"
"""
input limit_permissions_min_order_by {
  end_date: order_by
  id: order_by
  number: order_by
  release_source_id: order_by
  start_date: order_by
  t_year_limit: order_by
}

"""
response of any mutation on the table "limit_permissions"
"""
type limit_permissions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [limit_permissions!]!
}

"""
input type for inserting object relation for remote table "limit_permissions"
"""
input limit_permissions_obj_rel_insert_input {
  data: limit_permissions_insert_input!
  on_conflict: limit_permissions_on_conflict
}

"""
on conflict condition type for table "limit_permissions"
"""
input limit_permissions_on_conflict {
  constraint: limit_permissions_constraint!
  update_columns: [limit_permissions_update_column!]!
  where: limit_permissions_bool_exp
}

"""
ordering options when selecting data from "limit_permissions"
"""
input limit_permissions_order_by {
  end_date: order_by
  id: order_by
  number: order_by
  release_source_id: order_by
  start_date: order_by
  t_year_limit: order_by
}

"""
primary key columns input for table: "limit_permissions"
"""
input limit_permissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "limit_permissions"
"""
enum limit_permissions_select_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  number

  """column name"""
  release_source_id

  """column name"""
  start_date

  """column name"""
  t_year_limit
}

"""
input type for updating data in table "limit_permissions"
"""
input limit_permissions_set_input {
  end_date: date
  id: uuid
  number: String
  release_source_id: uuid
  start_date: date
  t_year_limit: Int
}

"""aggregate stddev on columns"""
type limit_permissions_stddev_fields {
  t_year_limit: Float
}

"""
order by stddev() on columns of table "limit_permissions"
"""
input limit_permissions_stddev_order_by {
  t_year_limit: order_by
}

"""aggregate stddev_pop on columns"""
type limit_permissions_stddev_pop_fields {
  t_year_limit: Float
}

"""
order by stddev_pop() on columns of table "limit_permissions"
"""
input limit_permissions_stddev_pop_order_by {
  t_year_limit: order_by
}

"""aggregate stddev_samp on columns"""
type limit_permissions_stddev_samp_fields {
  t_year_limit: Float
}

"""
order by stddev_samp() on columns of table "limit_permissions"
"""
input limit_permissions_stddev_samp_order_by {
  t_year_limit: order_by
}

"""aggregate sum on columns"""
type limit_permissions_sum_fields {
  t_year_limit: Int
}

"""
order by sum() on columns of table "limit_permissions"
"""
input limit_permissions_sum_order_by {
  t_year_limit: order_by
}

"""
update columns of table "limit_permissions"
"""
enum limit_permissions_update_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  number

  """column name"""
  release_source_id

  """column name"""
  start_date

  """column name"""
  t_year_limit
}

"""aggregate var_pop on columns"""
type limit_permissions_var_pop_fields {
  t_year_limit: Float
}

"""
order by var_pop() on columns of table "limit_permissions"
"""
input limit_permissions_var_pop_order_by {
  t_year_limit: order_by
}

"""aggregate var_samp on columns"""
type limit_permissions_var_samp_fields {
  t_year_limit: Float
}

"""
order by var_samp() on columns of table "limit_permissions"
"""
input limit_permissions_var_samp_order_by {
  t_year_limit: order_by
}

"""aggregate variance on columns"""
type limit_permissions_variance_fields {
  t_year_limit: Float
}

"""
order by variance() on columns of table "limit_permissions"
"""
input limit_permissions_variance_order_by {
  t_year_limit: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "bank_accounts"
  """
  delete_bank_accounts(
    """filter the rows which have to be deleted"""
    where: bank_accounts_bool_exp!
  ): bank_accounts_mutation_response

  """
  delete single row from the table: "bank_accounts"
  """
  delete_bank_accounts_by_pk(id: uuid!): bank_accounts

  """
  delete data from the table: "banks"
  """
  delete_banks(
    """filter the rows which have to be deleted"""
    where: banks_bool_exp!
  ): banks_mutation_response

  """
  delete single row from the table: "banks"
  """
  delete_banks_by_pk(id: uuid!): banks

  """
  delete data from the table: "cities"
  """
  delete_cities(
    """filter the rows which have to be deleted"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  delete single row from the table: "cities"
  """
  delete_cities_by_pk(id: uuid!): cities

  """
  delete data from the table: "companies"
  """
  delete_companies(
    """filter the rows which have to be deleted"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  delete single row from the table: "companies"
  """
  delete_companies_by_pk(id: uuid!): companies

  """
  delete data from the table: "company_addresses"
  """
  delete_company_addresses(
    """filter the rows which have to be deleted"""
    where: company_addresses_bool_exp!
  ): company_addresses_mutation_response

  """
  delete single row from the table: "company_addresses"
  """
  delete_company_addresses_by_pk(id: uuid!): company_addresses

  """
  delete data from the table: "company_departments"
  """
  delete_company_departments(
    """filter the rows which have to be deleted"""
    where: company_departments_bool_exp!
  ): company_departments_mutation_response

  """
  delete single row from the table: "company_departments"
  """
  delete_company_departments_by_pk(id: uuid!): company_departments

  """
  delete data from the table: "company_types"
  """
  delete_company_types(
    """filter the rows which have to be deleted"""
    where: company_types_bool_exp!
  ): company_types_mutation_response

  """
  delete single row from the table: "company_types"
  """
  delete_company_types_by_pk(id: uuid!): company_types

  """
  delete data from the table: "countries"
  """
  delete_countries(
    """filter the rows which have to be deleted"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  delete single row from the table: "countries"
  """
  delete_countries_by_pk(id: uuid!): countries

  """
  delete data from the table: "currencies"
  """
  delete_currencies(
    """filter the rows which have to be deleted"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  delete single row from the table: "currencies"
  """
  delete_currencies_by_pk(id: uuid!): currencies

  """
  delete data from the table: "emission_sources"
  """
  delete_emission_sources(
    """filter the rows which have to be deleted"""
    where: emission_sources_bool_exp!
  ): emission_sources_mutation_response

  """
  delete single row from the table: "emission_sources"
  """
  delete_emission_sources_by_pk(id: uuid!): emission_sources

  """
  delete data from the table: "employee_positions"
  """
  delete_employee_positions(
    """filter the rows which have to be deleted"""
    where: employee_positions_bool_exp!
  ): employee_positions_mutation_response

  """
  delete single row from the table: "employee_positions"
  """
  delete_employee_positions_by_pk(id: uuid!): employee_positions

  """
  delete data from the table: "employees"
  """
  delete_employees(
    """filter the rows which have to be deleted"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  delete single row from the table: "employees"
  """
  delete_employees_by_pk(id: uuid!): employees

  """
  delete data from the table: "facilities"
  """
  delete_facilities(
    """filter the rows which have to be deleted"""
    where: facilities_bool_exp!
  ): facilities_mutation_response

  """
  delete single row from the table: "facilities"
  """
  delete_facilities_by_pk(id: uuid!): facilities

  """
  delete data from the table: "facility_locations"
  """
  delete_facility_locations(
    """filter the rows which have to be deleted"""
    where: facility_locations_bool_exp!
  ): facility_locations_mutation_response

  """
  delete single row from the table: "facility_locations"
  """
  delete_facility_locations_by_pk(id: uuid!): facility_locations

  """
  delete data from the table: "filter_equipments"
  """
  delete_filter_equipments(
    """filter the rows which have to be deleted"""
    where: filter_equipments_bool_exp!
  ): filter_equipments_mutation_response

  """
  delete single row from the table: "filter_equipments"
  """
  delete_filter_equipments_by_pk(id: uuid!): filter_equipments

  """
  delete data from the table: "limit_permissions"
  """
  delete_limit_permissions(
    """filter the rows which have to be deleted"""
    where: limit_permissions_bool_exp!
  ): limit_permissions_mutation_response

  """
  delete single row from the table: "limit_permissions"
  """
  delete_limit_permissions_by_pk(id: uuid!): limit_permissions

  """
  delete data from the table: "permission_pol_groups"
  """
  delete_permission_pol_groups(
    """filter the rows which have to be deleted"""
    where: permission_pol_groups_bool_exp!
  ): permission_pol_groups_mutation_response

  """
  delete single row from the table: "permission_pol_groups"
  """
  delete_permission_pol_groups_by_pk(id: uuid!): permission_pol_groups

  """
  delete data from the table: "pollutant_groups"
  """
  delete_pollutant_groups(
    """filter the rows which have to be deleted"""
    where: pollutant_groups_bool_exp!
  ): pollutant_groups_mutation_response

  """
  delete single row from the table: "pollutant_groups"
  """
  delete_pollutant_groups_by_pk(id: uuid!): pollutant_groups

  """
  delete data from the table: "pollutants"
  """
  delete_pollutants(
    """filter the rows which have to be deleted"""
    where: pollutants_bool_exp!
  ): pollutants_mutation_response

  """
  delete single row from the table: "pollutants"
  """
  delete_pollutants_by_pk(id: uuid!): pollutants

  """
  delete data from the table: "release_sources"
  """
  delete_release_sources(
    """filter the rows which have to be deleted"""
    where: release_sources_bool_exp!
  ): release_sources_mutation_response

  """
  delete single row from the table: "release_sources"
  """
  delete_release_sources_by_pk(id: uuid!): release_sources

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: Int!): roles

  """
  delete data from the table: "states"
  """
  delete_states(
    """filter the rows which have to be deleted"""
    where: states_bool_exp!
  ): states_mutation_response

  """
  delete single row from the table: "states"
  """
  delete_states_by_pk(id: uuid!): states

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: Int!): users

  """
  delete data from the table: "worksite_categories"
  """
  delete_worksite_categories(
    """filter the rows which have to be deleted"""
    where: worksite_categories_bool_exp!
  ): worksite_categories_mutation_response

  """
  delete single row from the table: "worksite_categories"
  """
  delete_worksite_categories_by_pk(id: uuid!): worksite_categories

  """
  delete data from the table: "worksites"
  """
  delete_worksites(
    """filter the rows which have to be deleted"""
    where: worksites_bool_exp!
  ): worksites_mutation_response

  """
  delete single row from the table: "worksites"
  """
  delete_worksites_by_pk(id: uuid!): worksites

  """
  insert data into the table: "bank_accounts"
  """
  insert_bank_accounts(
    """the rows to be inserted"""
    objects: [bank_accounts_insert_input!]!

    """on conflict condition"""
    on_conflict: bank_accounts_on_conflict
  ): bank_accounts_mutation_response

  """
  insert a single row into the table: "bank_accounts"
  """
  insert_bank_accounts_one(
    """the row to be inserted"""
    object: bank_accounts_insert_input!

    """on conflict condition"""
    on_conflict: bank_accounts_on_conflict
  ): bank_accounts

  """
  insert data into the table: "banks"
  """
  insert_banks(
    """the rows to be inserted"""
    objects: [banks_insert_input!]!

    """on conflict condition"""
    on_conflict: banks_on_conflict
  ): banks_mutation_response

  """
  insert a single row into the table: "banks"
  """
  insert_banks_one(
    """the row to be inserted"""
    object: banks_insert_input!

    """on conflict condition"""
    on_conflict: banks_on_conflict
  ): banks

  """
  insert data into the table: "cities"
  """
  insert_cities(
    """the rows to be inserted"""
    objects: [cities_insert_input!]!

    """on conflict condition"""
    on_conflict: cities_on_conflict
  ): cities_mutation_response

  """
  insert a single row into the table: "cities"
  """
  insert_cities_one(
    """the row to be inserted"""
    object: cities_insert_input!

    """on conflict condition"""
    on_conflict: cities_on_conflict
  ): cities

  """
  insert data into the table: "companies"
  """
  insert_companies(
    """the rows to be inserted"""
    objects: [companies_insert_input!]!

    """on conflict condition"""
    on_conflict: companies_on_conflict
  ): companies_mutation_response

  """
  insert a single row into the table: "companies"
  """
  insert_companies_one(
    """the row to be inserted"""
    object: companies_insert_input!

    """on conflict condition"""
    on_conflict: companies_on_conflict
  ): companies

  """
  insert data into the table: "company_addresses"
  """
  insert_company_addresses(
    """the rows to be inserted"""
    objects: [company_addresses_insert_input!]!

    """on conflict condition"""
    on_conflict: company_addresses_on_conflict
  ): company_addresses_mutation_response

  """
  insert a single row into the table: "company_addresses"
  """
  insert_company_addresses_one(
    """the row to be inserted"""
    object: company_addresses_insert_input!

    """on conflict condition"""
    on_conflict: company_addresses_on_conflict
  ): company_addresses

  """
  insert data into the table: "company_departments"
  """
  insert_company_departments(
    """the rows to be inserted"""
    objects: [company_departments_insert_input!]!

    """on conflict condition"""
    on_conflict: company_departments_on_conflict
  ): company_departments_mutation_response

  """
  insert a single row into the table: "company_departments"
  """
  insert_company_departments_one(
    """the row to be inserted"""
    object: company_departments_insert_input!

    """on conflict condition"""
    on_conflict: company_departments_on_conflict
  ): company_departments

  """
  insert data into the table: "company_types"
  """
  insert_company_types(
    """the rows to be inserted"""
    objects: [company_types_insert_input!]!

    """on conflict condition"""
    on_conflict: company_types_on_conflict
  ): company_types_mutation_response

  """
  insert a single row into the table: "company_types"
  """
  insert_company_types_one(
    """the row to be inserted"""
    object: company_types_insert_input!

    """on conflict condition"""
    on_conflict: company_types_on_conflict
  ): company_types

  """
  insert data into the table: "countries"
  """
  insert_countries(
    """the rows to be inserted"""
    objects: [countries_insert_input!]!

    """on conflict condition"""
    on_conflict: countries_on_conflict
  ): countries_mutation_response

  """
  insert a single row into the table: "countries"
  """
  insert_countries_one(
    """the row to be inserted"""
    object: countries_insert_input!

    """on conflict condition"""
    on_conflict: countries_on_conflict
  ): countries

  """
  insert data into the table: "currencies"
  """
  insert_currencies(
    """the rows to be inserted"""
    objects: [currencies_insert_input!]!

    """on conflict condition"""
    on_conflict: currencies_on_conflict
  ): currencies_mutation_response

  """
  insert a single row into the table: "currencies"
  """
  insert_currencies_one(
    """the row to be inserted"""
    object: currencies_insert_input!

    """on conflict condition"""
    on_conflict: currencies_on_conflict
  ): currencies

  """
  insert data into the table: "emission_sources"
  """
  insert_emission_sources(
    """the rows to be inserted"""
    objects: [emission_sources_insert_input!]!

    """on conflict condition"""
    on_conflict: emission_sources_on_conflict
  ): emission_sources_mutation_response

  """
  insert a single row into the table: "emission_sources"
  """
  insert_emission_sources_one(
    """the row to be inserted"""
    object: emission_sources_insert_input!

    """on conflict condition"""
    on_conflict: emission_sources_on_conflict
  ): emission_sources

  """
  insert data into the table: "employee_positions"
  """
  insert_employee_positions(
    """the rows to be inserted"""
    objects: [employee_positions_insert_input!]!

    """on conflict condition"""
    on_conflict: employee_positions_on_conflict
  ): employee_positions_mutation_response

  """
  insert a single row into the table: "employee_positions"
  """
  insert_employee_positions_one(
    """the row to be inserted"""
    object: employee_positions_insert_input!

    """on conflict condition"""
    on_conflict: employee_positions_on_conflict
  ): employee_positions

  """
  insert data into the table: "employees"
  """
  insert_employees(
    """the rows to be inserted"""
    objects: [employees_insert_input!]!

    """on conflict condition"""
    on_conflict: employees_on_conflict
  ): employees_mutation_response

  """
  insert a single row into the table: "employees"
  """
  insert_employees_one(
    """the row to be inserted"""
    object: employees_insert_input!

    """on conflict condition"""
    on_conflict: employees_on_conflict
  ): employees

  """
  insert data into the table: "facilities"
  """
  insert_facilities(
    """the rows to be inserted"""
    objects: [facilities_insert_input!]!

    """on conflict condition"""
    on_conflict: facilities_on_conflict
  ): facilities_mutation_response

  """
  insert a single row into the table: "facilities"
  """
  insert_facilities_one(
    """the row to be inserted"""
    object: facilities_insert_input!

    """on conflict condition"""
    on_conflict: facilities_on_conflict
  ): facilities

  """
  insert data into the table: "facility_locations"
  """
  insert_facility_locations(
    """the rows to be inserted"""
    objects: [facility_locations_insert_input!]!

    """on conflict condition"""
    on_conflict: facility_locations_on_conflict
  ): facility_locations_mutation_response

  """
  insert a single row into the table: "facility_locations"
  """
  insert_facility_locations_one(
    """the row to be inserted"""
    object: facility_locations_insert_input!

    """on conflict condition"""
    on_conflict: facility_locations_on_conflict
  ): facility_locations

  """
  insert data into the table: "filter_equipments"
  """
  insert_filter_equipments(
    """the rows to be inserted"""
    objects: [filter_equipments_insert_input!]!

    """on conflict condition"""
    on_conflict: filter_equipments_on_conflict
  ): filter_equipments_mutation_response

  """
  insert a single row into the table: "filter_equipments"
  """
  insert_filter_equipments_one(
    """the row to be inserted"""
    object: filter_equipments_insert_input!

    """on conflict condition"""
    on_conflict: filter_equipments_on_conflict
  ): filter_equipments

  """
  insert data into the table: "limit_permissions"
  """
  insert_limit_permissions(
    """the rows to be inserted"""
    objects: [limit_permissions_insert_input!]!

    """on conflict condition"""
    on_conflict: limit_permissions_on_conflict
  ): limit_permissions_mutation_response

  """
  insert a single row into the table: "limit_permissions"
  """
  insert_limit_permissions_one(
    """the row to be inserted"""
    object: limit_permissions_insert_input!

    """on conflict condition"""
    on_conflict: limit_permissions_on_conflict
  ): limit_permissions

  """
  insert data into the table: "permission_pol_groups"
  """
  insert_permission_pol_groups(
    """the rows to be inserted"""
    objects: [permission_pol_groups_insert_input!]!

    """on conflict condition"""
    on_conflict: permission_pol_groups_on_conflict
  ): permission_pol_groups_mutation_response

  """
  insert a single row into the table: "permission_pol_groups"
  """
  insert_permission_pol_groups_one(
    """the row to be inserted"""
    object: permission_pol_groups_insert_input!

    """on conflict condition"""
    on_conflict: permission_pol_groups_on_conflict
  ): permission_pol_groups

  """
  insert data into the table: "pollutant_groups"
  """
  insert_pollutant_groups(
    """the rows to be inserted"""
    objects: [pollutant_groups_insert_input!]!

    """on conflict condition"""
    on_conflict: pollutant_groups_on_conflict
  ): pollutant_groups_mutation_response

  """
  insert a single row into the table: "pollutant_groups"
  """
  insert_pollutant_groups_one(
    """the row to be inserted"""
    object: pollutant_groups_insert_input!

    """on conflict condition"""
    on_conflict: pollutant_groups_on_conflict
  ): pollutant_groups

  """
  insert data into the table: "pollutants"
  """
  insert_pollutants(
    """the rows to be inserted"""
    objects: [pollutants_insert_input!]!

    """on conflict condition"""
    on_conflict: pollutants_on_conflict
  ): pollutants_mutation_response

  """
  insert a single row into the table: "pollutants"
  """
  insert_pollutants_one(
    """the row to be inserted"""
    object: pollutants_insert_input!

    """on conflict condition"""
    on_conflict: pollutants_on_conflict
  ): pollutants

  """
  insert data into the table: "release_sources"
  """
  insert_release_sources(
    """the rows to be inserted"""
    objects: [release_sources_insert_input!]!

    """on conflict condition"""
    on_conflict: release_sources_on_conflict
  ): release_sources_mutation_response

  """
  insert a single row into the table: "release_sources"
  """
  insert_release_sources_one(
    """the row to be inserted"""
    object: release_sources_insert_input!

    """on conflict condition"""
    on_conflict: release_sources_on_conflict
  ): release_sources

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "states"
  """
  insert_states(
    """the rows to be inserted"""
    objects: [states_insert_input!]!

    """on conflict condition"""
    on_conflict: states_on_conflict
  ): states_mutation_response

  """
  insert a single row into the table: "states"
  """
  insert_states_one(
    """the row to be inserted"""
    object: states_insert_input!

    """on conflict condition"""
    on_conflict: states_on_conflict
  ): states

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "worksite_categories"
  """
  insert_worksite_categories(
    """the rows to be inserted"""
    objects: [worksite_categories_insert_input!]!

    """on conflict condition"""
    on_conflict: worksite_categories_on_conflict
  ): worksite_categories_mutation_response

  """
  insert a single row into the table: "worksite_categories"
  """
  insert_worksite_categories_one(
    """the row to be inserted"""
    object: worksite_categories_insert_input!

    """on conflict condition"""
    on_conflict: worksite_categories_on_conflict
  ): worksite_categories

  """
  insert data into the table: "worksites"
  """
  insert_worksites(
    """the rows to be inserted"""
    objects: [worksites_insert_input!]!

    """on conflict condition"""
    on_conflict: worksites_on_conflict
  ): worksites_mutation_response

  """
  insert a single row into the table: "worksites"
  """
  insert_worksites_one(
    """the row to be inserted"""
    object: worksites_insert_input!

    """on conflict condition"""
    on_conflict: worksites_on_conflict
  ): worksites

  """
  perform the action: "login"
  """
  login(email: String!, password: String!): UserInfo

  """
  perform the action: "refresh_token"
  """
  refresh_token(email: String!): UserInfo

  """
  perform the action: "registration"
  """
  registration(email: String!, password: String!): Token

  """
  update data of the table: "bank_accounts"
  """
  update_bank_accounts(
    """sets the columns of the filtered rows to the given values"""
    _set: bank_accounts_set_input

    """filter the rows which have to be updated"""
    where: bank_accounts_bool_exp!
  ): bank_accounts_mutation_response

  """
  update single row of the table: "bank_accounts"
  """
  update_bank_accounts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: bank_accounts_set_input
    pk_columns: bank_accounts_pk_columns_input!
  ): bank_accounts

  """
  update data of the table: "banks"
  """
  update_banks(
    """sets the columns of the filtered rows to the given values"""
    _set: banks_set_input

    """filter the rows which have to be updated"""
    where: banks_bool_exp!
  ): banks_mutation_response

  """
  update single row of the table: "banks"
  """
  update_banks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: banks_set_input
    pk_columns: banks_pk_columns_input!
  ): banks

  """
  update data of the table: "cities"
  """
  update_cities(
    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input

    """filter the rows which have to be updated"""
    where: cities_bool_exp!
  ): cities_mutation_response

  """
  update single row of the table: "cities"
  """
  update_cities_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: cities_set_input
    pk_columns: cities_pk_columns_input!
  ): cities

  """
  update data of the table: "companies"
  """
  update_companies(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input

    """filter the rows which have to be updated"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  update single row of the table: "companies"
  """
  update_companies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input
    pk_columns: companies_pk_columns_input!
  ): companies

  """
  update data of the table: "company_addresses"
  """
  update_company_addresses(
    """sets the columns of the filtered rows to the given values"""
    _set: company_addresses_set_input

    """filter the rows which have to be updated"""
    where: company_addresses_bool_exp!
  ): company_addresses_mutation_response

  """
  update single row of the table: "company_addresses"
  """
  update_company_addresses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_addresses_set_input
    pk_columns: company_addresses_pk_columns_input!
  ): company_addresses

  """
  update data of the table: "company_departments"
  """
  update_company_departments(
    """sets the columns of the filtered rows to the given values"""
    _set: company_departments_set_input

    """filter the rows which have to be updated"""
    where: company_departments_bool_exp!
  ): company_departments_mutation_response

  """
  update single row of the table: "company_departments"
  """
  update_company_departments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_departments_set_input
    pk_columns: company_departments_pk_columns_input!
  ): company_departments

  """
  update data of the table: "company_types"
  """
  update_company_types(
    """sets the columns of the filtered rows to the given values"""
    _set: company_types_set_input

    """filter the rows which have to be updated"""
    where: company_types_bool_exp!
  ): company_types_mutation_response

  """
  update single row of the table: "company_types"
  """
  update_company_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_types_set_input
    pk_columns: company_types_pk_columns_input!
  ): company_types

  """
  update data of the table: "countries"
  """
  update_countries(
    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input

    """filter the rows which have to be updated"""
    where: countries_bool_exp!
  ): countries_mutation_response

  """
  update single row of the table: "countries"
  """
  update_countries_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: countries_set_input
    pk_columns: countries_pk_columns_input!
  ): countries

  """
  update data of the table: "currencies"
  """
  update_currencies(
    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input

    """filter the rows which have to be updated"""
    where: currencies_bool_exp!
  ): currencies_mutation_response

  """
  update single row of the table: "currencies"
  """
  update_currencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: currencies_set_input
    pk_columns: currencies_pk_columns_input!
  ): currencies

  """
  update data of the table: "emission_sources"
  """
  update_emission_sources(
    """sets the columns of the filtered rows to the given values"""
    _set: emission_sources_set_input

    """filter the rows which have to be updated"""
    where: emission_sources_bool_exp!
  ): emission_sources_mutation_response

  """
  update single row of the table: "emission_sources"
  """
  update_emission_sources_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: emission_sources_set_input
    pk_columns: emission_sources_pk_columns_input!
  ): emission_sources

  """
  update data of the table: "employee_positions"
  """
  update_employee_positions(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_positions_set_input

    """filter the rows which have to be updated"""
    where: employee_positions_bool_exp!
  ): employee_positions_mutation_response

  """
  update single row of the table: "employee_positions"
  """
  update_employee_positions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_positions_set_input
    pk_columns: employee_positions_pk_columns_input!
  ): employee_positions

  """
  update data of the table: "employees"
  """
  update_employees(
    """increments the integer columns with given value of the filtered values"""
    _inc: employees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input

    """filter the rows which have to be updated"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  update single row of the table: "employees"
  """
  update_employees_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: employees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input
    pk_columns: employees_pk_columns_input!
  ): employees

  """
  update data of the table: "facilities"
  """
  update_facilities(
    """sets the columns of the filtered rows to the given values"""
    _set: facilities_set_input

    """filter the rows which have to be updated"""
    where: facilities_bool_exp!
  ): facilities_mutation_response

  """
  update single row of the table: "facilities"
  """
  update_facilities_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: facilities_set_input
    pk_columns: facilities_pk_columns_input!
  ): facilities

  """
  update data of the table: "facility_locations"
  """
  update_facility_locations(
    """sets the columns of the filtered rows to the given values"""
    _set: facility_locations_set_input

    """filter the rows which have to be updated"""
    where: facility_locations_bool_exp!
  ): facility_locations_mutation_response

  """
  update single row of the table: "facility_locations"
  """
  update_facility_locations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: facility_locations_set_input
    pk_columns: facility_locations_pk_columns_input!
  ): facility_locations

  """
  update data of the table: "filter_equipments"
  """
  update_filter_equipments(
    """sets the columns of the filtered rows to the given values"""
    _set: filter_equipments_set_input

    """filter the rows which have to be updated"""
    where: filter_equipments_bool_exp!
  ): filter_equipments_mutation_response

  """
  update single row of the table: "filter_equipments"
  """
  update_filter_equipments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: filter_equipments_set_input
    pk_columns: filter_equipments_pk_columns_input!
  ): filter_equipments

  """
  update data of the table: "limit_permissions"
  """
  update_limit_permissions(
    """increments the integer columns with given value of the filtered values"""
    _inc: limit_permissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: limit_permissions_set_input

    """filter the rows which have to be updated"""
    where: limit_permissions_bool_exp!
  ): limit_permissions_mutation_response

  """
  update single row of the table: "limit_permissions"
  """
  update_limit_permissions_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: limit_permissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: limit_permissions_set_input
    pk_columns: limit_permissions_pk_columns_input!
  ): limit_permissions

  """
  update data of the table: "permission_pol_groups"
  """
  update_permission_pol_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: permission_pol_groups_set_input

    """filter the rows which have to be updated"""
    where: permission_pol_groups_bool_exp!
  ): permission_pol_groups_mutation_response

  """
  update single row of the table: "permission_pol_groups"
  """
  update_permission_pol_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: permission_pol_groups_set_input
    pk_columns: permission_pol_groups_pk_columns_input!
  ): permission_pol_groups

  """
  update data of the table: "pollutant_groups"
  """
  update_pollutant_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: pollutant_groups_set_input

    """filter the rows which have to be updated"""
    where: pollutant_groups_bool_exp!
  ): pollutant_groups_mutation_response

  """
  update single row of the table: "pollutant_groups"
  """
  update_pollutant_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pollutant_groups_set_input
    pk_columns: pollutant_groups_pk_columns_input!
  ): pollutant_groups

  """
  update data of the table: "pollutants"
  """
  update_pollutants(
    """sets the columns of the filtered rows to the given values"""
    _set: pollutants_set_input

    """filter the rows which have to be updated"""
    where: pollutants_bool_exp!
  ): pollutants_mutation_response

  """
  update single row of the table: "pollutants"
  """
  update_pollutants_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pollutants_set_input
    pk_columns: pollutants_pk_columns_input!
  ): pollutants

  """
  update data of the table: "release_sources"
  """
  update_release_sources(
    """sets the columns of the filtered rows to the given values"""
    _set: release_sources_set_input

    """filter the rows which have to be updated"""
    where: release_sources_bool_exp!
  ): release_sources_mutation_response

  """
  update single row of the table: "release_sources"
  """
  update_release_sources_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: release_sources_set_input
    pk_columns: release_sources_pk_columns_input!
  ): release_sources

  """
  update data of the table: "roles"
  """
  update_roles(
    """increments the integer columns with given value of the filtered values"""
    _inc: roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update data of the table: "states"
  """
  update_states(
    """sets the columns of the filtered rows to the given values"""
    _set: states_set_input

    """filter the rows which have to be updated"""
    where: states_bool_exp!
  ): states_mutation_response

  """
  update single row of the table: "states"
  """
  update_states_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: states_set_input
    pk_columns: states_pk_columns_input!
  ): states

  """
  update data of the table: "users"
  """
  update_users(
    """increments the integer columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "worksite_categories"
  """
  update_worksite_categories(
    """sets the columns of the filtered rows to the given values"""
    _set: worksite_categories_set_input

    """filter the rows which have to be updated"""
    where: worksite_categories_bool_exp!
  ): worksite_categories_mutation_response

  """
  update single row of the table: "worksite_categories"
  """
  update_worksite_categories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: worksite_categories_set_input
    pk_columns: worksite_categories_pk_columns_input!
  ): worksite_categories

  """
  update data of the table: "worksites"
  """
  update_worksites(
    """sets the columns of the filtered rows to the given values"""
    _set: worksites_set_input

    """filter the rows which have to be updated"""
    where: worksites_bool_exp!
  ): worksites_mutation_response

  """
  update single row of the table: "worksites"
  """
  update_worksites_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: worksites_set_input
    pk_columns: worksites_pk_columns_input!
  ): worksites
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "permission_pol_groups"
"""
type permission_pol_groups {
  id: uuid!
  limit_permission_id: uuid!
  poll_group_id: uuid!
}

"""
aggregated selection of "permission_pol_groups"
"""
type permission_pol_groups_aggregate {
  aggregate: permission_pol_groups_aggregate_fields
  nodes: [permission_pol_groups!]!
}

"""
aggregate fields of "permission_pol_groups"
"""
type permission_pol_groups_aggregate_fields {
  count(columns: [permission_pol_groups_select_column!], distinct: Boolean): Int
  max: permission_pol_groups_max_fields
  min: permission_pol_groups_min_fields
}

"""
order by aggregate values of table "permission_pol_groups"
"""
input permission_pol_groups_aggregate_order_by {
  count: order_by
  max: permission_pol_groups_max_order_by
  min: permission_pol_groups_min_order_by
}

"""
input type for inserting array relation for remote table "permission_pol_groups"
"""
input permission_pol_groups_arr_rel_insert_input {
  data: [permission_pol_groups_insert_input!]!
  on_conflict: permission_pol_groups_on_conflict
}

"""
Boolean expression to filter rows from the table "permission_pol_groups". All fields are combined with a logical 'AND'.
"""
input permission_pol_groups_bool_exp {
  _and: [permission_pol_groups_bool_exp]
  _not: permission_pol_groups_bool_exp
  _or: [permission_pol_groups_bool_exp]
  id: uuid_comparison_exp
  limit_permission_id: uuid_comparison_exp
  poll_group_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "permission_pol_groups"
"""
enum permission_pol_groups_constraint {
  """unique or primary key constraint"""
  permission_pol_groups_pkey
}

"""
input type for inserting data into table "permission_pol_groups"
"""
input permission_pol_groups_insert_input {
  id: uuid
  limit_permission_id: uuid
  poll_group_id: uuid
}

"""aggregate max on columns"""
type permission_pol_groups_max_fields {
  id: uuid
  limit_permission_id: uuid
  poll_group_id: uuid
}

"""
order by max() on columns of table "permission_pol_groups"
"""
input permission_pol_groups_max_order_by {
  id: order_by
  limit_permission_id: order_by
  poll_group_id: order_by
}

"""aggregate min on columns"""
type permission_pol_groups_min_fields {
  id: uuid
  limit_permission_id: uuid
  poll_group_id: uuid
}

"""
order by min() on columns of table "permission_pol_groups"
"""
input permission_pol_groups_min_order_by {
  id: order_by
  limit_permission_id: order_by
  poll_group_id: order_by
}

"""
response of any mutation on the table "permission_pol_groups"
"""
type permission_pol_groups_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [permission_pol_groups!]!
}

"""
input type for inserting object relation for remote table "permission_pol_groups"
"""
input permission_pol_groups_obj_rel_insert_input {
  data: permission_pol_groups_insert_input!
  on_conflict: permission_pol_groups_on_conflict
}

"""
on conflict condition type for table "permission_pol_groups"
"""
input permission_pol_groups_on_conflict {
  constraint: permission_pol_groups_constraint!
  update_columns: [permission_pol_groups_update_column!]!
  where: permission_pol_groups_bool_exp
}

"""
ordering options when selecting data from "permission_pol_groups"
"""
input permission_pol_groups_order_by {
  id: order_by
  limit_permission_id: order_by
  poll_group_id: order_by
}

"""
primary key columns input for table: "permission_pol_groups"
"""
input permission_pol_groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "permission_pol_groups"
"""
enum permission_pol_groups_select_column {
  """column name"""
  id

  """column name"""
  limit_permission_id

  """column name"""
  poll_group_id
}

"""
input type for updating data in table "permission_pol_groups"
"""
input permission_pol_groups_set_input {
  id: uuid
  limit_permission_id: uuid
  poll_group_id: uuid
}

"""
update columns of table "permission_pol_groups"
"""
enum permission_pol_groups_update_column {
  """column name"""
  id

  """column name"""
  limit_permission_id

  """column name"""
  poll_group_id
}

"""
columns and relationships of "pollutant_groups"
"""
type pollutant_groups {
  id: uuid!
  pollutant_id: uuid!
}

"""
aggregated selection of "pollutant_groups"
"""
type pollutant_groups_aggregate {
  aggregate: pollutant_groups_aggregate_fields
  nodes: [pollutant_groups!]!
}

"""
aggregate fields of "pollutant_groups"
"""
type pollutant_groups_aggregate_fields {
  count(columns: [pollutant_groups_select_column!], distinct: Boolean): Int
  max: pollutant_groups_max_fields
  min: pollutant_groups_min_fields
}

"""
order by aggregate values of table "pollutant_groups"
"""
input pollutant_groups_aggregate_order_by {
  count: order_by
  max: pollutant_groups_max_order_by
  min: pollutant_groups_min_order_by
}

"""
input type for inserting array relation for remote table "pollutant_groups"
"""
input pollutant_groups_arr_rel_insert_input {
  data: [pollutant_groups_insert_input!]!
  on_conflict: pollutant_groups_on_conflict
}

"""
Boolean expression to filter rows from the table "pollutant_groups". All fields are combined with a logical 'AND'.
"""
input pollutant_groups_bool_exp {
  _and: [pollutant_groups_bool_exp]
  _not: pollutant_groups_bool_exp
  _or: [pollutant_groups_bool_exp]
  id: uuid_comparison_exp
  pollutant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "pollutant_groups"
"""
enum pollutant_groups_constraint {
  """unique or primary key constraint"""
  pollutant_groups_pkey
}

"""
input type for inserting data into table "pollutant_groups"
"""
input pollutant_groups_insert_input {
  id: uuid
  pollutant_id: uuid
}

"""aggregate max on columns"""
type pollutant_groups_max_fields {
  id: uuid
  pollutant_id: uuid
}

"""
order by max() on columns of table "pollutant_groups"
"""
input pollutant_groups_max_order_by {
  id: order_by
  pollutant_id: order_by
}

"""aggregate min on columns"""
type pollutant_groups_min_fields {
  id: uuid
  pollutant_id: uuid
}

"""
order by min() on columns of table "pollutant_groups"
"""
input pollutant_groups_min_order_by {
  id: order_by
  pollutant_id: order_by
}

"""
response of any mutation on the table "pollutant_groups"
"""
type pollutant_groups_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [pollutant_groups!]!
}

"""
input type for inserting object relation for remote table "pollutant_groups"
"""
input pollutant_groups_obj_rel_insert_input {
  data: pollutant_groups_insert_input!
  on_conflict: pollutant_groups_on_conflict
}

"""
on conflict condition type for table "pollutant_groups"
"""
input pollutant_groups_on_conflict {
  constraint: pollutant_groups_constraint!
  update_columns: [pollutant_groups_update_column!]!
  where: pollutant_groups_bool_exp
}

"""
ordering options when selecting data from "pollutant_groups"
"""
input pollutant_groups_order_by {
  id: order_by
  pollutant_id: order_by
}

"""
primary key columns input for table: "pollutant_groups"
"""
input pollutant_groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pollutant_groups"
"""
enum pollutant_groups_select_column {
  """column name"""
  id

  """column name"""
  pollutant_id
}

"""
input type for updating data in table "pollutant_groups"
"""
input pollutant_groups_set_input {
  id: uuid
  pollutant_id: uuid
}

"""
update columns of table "pollutant_groups"
"""
enum pollutant_groups_update_column {
  """column name"""
  id

  """column name"""
  pollutant_id
}

"""
columns and relationships of "pollutants"
"""
type pollutants {
  id: uuid!
}

"""
aggregated selection of "pollutants"
"""
type pollutants_aggregate {
  aggregate: pollutants_aggregate_fields
  nodes: [pollutants!]!
}

"""
aggregate fields of "pollutants"
"""
type pollutants_aggregate_fields {
  count(columns: [pollutants_select_column!], distinct: Boolean): Int
  max: pollutants_max_fields
  min: pollutants_min_fields
}

"""
order by aggregate values of table "pollutants"
"""
input pollutants_aggregate_order_by {
  count: order_by
  max: pollutants_max_order_by
  min: pollutants_min_order_by
}

"""
input type for inserting array relation for remote table "pollutants"
"""
input pollutants_arr_rel_insert_input {
  data: [pollutants_insert_input!]!
  on_conflict: pollutants_on_conflict
}

"""
Boolean expression to filter rows from the table "pollutants". All fields are combined with a logical 'AND'.
"""
input pollutants_bool_exp {
  _and: [pollutants_bool_exp]
  _not: pollutants_bool_exp
  _or: [pollutants_bool_exp]
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "pollutants"
"""
enum pollutants_constraint {
  """unique or primary key constraint"""
  pollutants_pkey
}

"""
input type for inserting data into table "pollutants"
"""
input pollutants_insert_input {
  id: uuid
}

"""aggregate max on columns"""
type pollutants_max_fields {
  id: uuid
}

"""
order by max() on columns of table "pollutants"
"""
input pollutants_max_order_by {
  id: order_by
}

"""aggregate min on columns"""
type pollutants_min_fields {
  id: uuid
}

"""
order by min() on columns of table "pollutants"
"""
input pollutants_min_order_by {
  id: order_by
}

"""
response of any mutation on the table "pollutants"
"""
type pollutants_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [pollutants!]!
}

"""
input type for inserting object relation for remote table "pollutants"
"""
input pollutants_obj_rel_insert_input {
  data: pollutants_insert_input!
  on_conflict: pollutants_on_conflict
}

"""
on conflict condition type for table "pollutants"
"""
input pollutants_on_conflict {
  constraint: pollutants_constraint!
  update_columns: [pollutants_update_column!]!
  where: pollutants_bool_exp
}

"""
ordering options when selecting data from "pollutants"
"""
input pollutants_order_by {
  id: order_by
}

"""
primary key columns input for table: "pollutants"
"""
input pollutants_pk_columns_input {
  id: uuid!
}

"""
select columns of table "pollutants"
"""
enum pollutants_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "pollutants"
"""
input pollutants_set_input {
  id: uuid
}

"""
update columns of table "pollutants"
"""
enum pollutants_update_column {
  """column name"""
  id
}

"""query root"""
type query_root {
  """
  fetch data from the table: "bank_accounts"
  """
  bank_accounts(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): [bank_accounts!]!

  """
  fetch aggregated fields from the table: "bank_accounts"
  """
  bank_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): bank_accounts_aggregate!

  """fetch data from the table: "bank_accounts" using primary key columns"""
  bank_accounts_by_pk(id: uuid!): bank_accounts

  """
  fetch data from the table: "banks"
  """
  banks(
    """distinct select on columns"""
    distinct_on: [banks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [banks_order_by!]

    """filter the rows returned"""
    where: banks_bool_exp
  ): [banks!]!

  """
  fetch aggregated fields from the table: "banks"
  """
  banks_aggregate(
    """distinct select on columns"""
    distinct_on: [banks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [banks_order_by!]

    """filter the rows returned"""
    where: banks_bool_exp
  ): banks_aggregate!

  """fetch data from the table: "banks" using primary key columns"""
  banks_by_pk(id: uuid!): banks

  """
  fetch data from the table: "cities"
  """
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch aggregated fields from the table: "cities"
  """
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: uuid!): cities

  """
  fetch data from the table: "companies"
  """
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """
  fetch aggregated fields from the table: "companies"
  """
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table: "company_addresses"
  """
  company_addresses(
    """distinct select on columns"""
    distinct_on: [company_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_addresses_order_by!]

    """filter the rows returned"""
    where: company_addresses_bool_exp
  ): [company_addresses!]!

  """
  fetch aggregated fields from the table: "company_addresses"
  """
  company_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [company_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_addresses_order_by!]

    """filter the rows returned"""
    where: company_addresses_bool_exp
  ): company_addresses_aggregate!

  """
  fetch data from the table: "company_addresses" using primary key columns
  """
  company_addresses_by_pk(id: uuid!): company_addresses

  """
  fetch data from the table: "company_departments"
  """
  company_departments(
    """distinct select on columns"""
    distinct_on: [company_departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_departments_order_by!]

    """filter the rows returned"""
    where: company_departments_bool_exp
  ): [company_departments!]!

  """
  fetch aggregated fields from the table: "company_departments"
  """
  company_departments_aggregate(
    """distinct select on columns"""
    distinct_on: [company_departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_departments_order_by!]

    """filter the rows returned"""
    where: company_departments_bool_exp
  ): company_departments_aggregate!

  """
  fetch data from the table: "company_departments" using primary key columns
  """
  company_departments_by_pk(id: uuid!): company_departments

  """
  fetch data from the table: "company_types"
  """
  company_types(
    """distinct select on columns"""
    distinct_on: [company_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_types_order_by!]

    """filter the rows returned"""
    where: company_types_bool_exp
  ): [company_types!]!

  """
  fetch aggregated fields from the table: "company_types"
  """
  company_types_aggregate(
    """distinct select on columns"""
    distinct_on: [company_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_types_order_by!]

    """filter the rows returned"""
    where: company_types_bool_exp
  ): company_types_aggregate!

  """fetch data from the table: "company_types" using primary key columns"""
  company_types_by_pk(id: uuid!): company_types

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: uuid!): countries

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(id: uuid!): currencies

  """
  fetch data from the table: "emission_sources"
  """
  emission_sources(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): [emission_sources!]!

  """
  fetch aggregated fields from the table: "emission_sources"
  """
  emission_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): emission_sources_aggregate!

  """
  fetch data from the table: "emission_sources" using primary key columns
  """
  emission_sources_by_pk(id: uuid!): emission_sources

  """
  fetch data from the table: "employee_positions"
  """
  employee_positions(
    """distinct select on columns"""
    distinct_on: [employee_positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_positions_order_by!]

    """filter the rows returned"""
    where: employee_positions_bool_exp
  ): [employee_positions!]!

  """
  fetch aggregated fields from the table: "employee_positions"
  """
  employee_positions_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_positions_order_by!]

    """filter the rows returned"""
    where: employee_positions_bool_exp
  ): employee_positions_aggregate!

  """
  fetch data from the table: "employee_positions" using primary key columns
  """
  employee_positions_by_pk(id: uuid!): employee_positions

  """
  fetch data from the table: "employees"
  """
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch aggregated fields from the table: "employees"
  """
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table: "facilities"
  """
  facilities(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): [facilities!]!

  """
  fetch aggregated fields from the table: "facilities"
  """
  facilities_aggregate(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): facilities_aggregate!

  """fetch data from the table: "facilities" using primary key columns"""
  facilities_by_pk(id: uuid!): facilities

  """
  fetch data from the table: "facility_locations"
  """
  facility_locations(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): [facility_locations!]!

  """
  fetch aggregated fields from the table: "facility_locations"
  """
  facility_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): facility_locations_aggregate!

  """
  fetch data from the table: "facility_locations" using primary key columns
  """
  facility_locations_by_pk(id: uuid!): facility_locations

  """
  fetch data from the table: "filter_equipments"
  """
  filter_equipments(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): [filter_equipments!]!

  """
  fetch aggregated fields from the table: "filter_equipments"
  """
  filter_equipments_aggregate(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): filter_equipments_aggregate!

  """
  fetch data from the table: "filter_equipments" using primary key columns
  """
  filter_equipments_by_pk(id: uuid!): filter_equipments

  """
  fetch data from the table: "limit_permissions"
  """
  limit_permissions(
    """distinct select on columns"""
    distinct_on: [limit_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [limit_permissions_order_by!]

    """filter the rows returned"""
    where: limit_permissions_bool_exp
  ): [limit_permissions!]!

  """
  fetch aggregated fields from the table: "limit_permissions"
  """
  limit_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [limit_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [limit_permissions_order_by!]

    """filter the rows returned"""
    where: limit_permissions_bool_exp
  ): limit_permissions_aggregate!

  """
  fetch data from the table: "limit_permissions" using primary key columns
  """
  limit_permissions_by_pk(id: uuid!): limit_permissions

  """
  fetch data from the table: "permission_pol_groups"
  """
  permission_pol_groups(
    """distinct select on columns"""
    distinct_on: [permission_pol_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_pol_groups_order_by!]

    """filter the rows returned"""
    where: permission_pol_groups_bool_exp
  ): [permission_pol_groups!]!

  """
  fetch aggregated fields from the table: "permission_pol_groups"
  """
  permission_pol_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_pol_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_pol_groups_order_by!]

    """filter the rows returned"""
    where: permission_pol_groups_bool_exp
  ): permission_pol_groups_aggregate!

  """
  fetch data from the table: "permission_pol_groups" using primary key columns
  """
  permission_pol_groups_by_pk(id: uuid!): permission_pol_groups

  """
  fetch data from the table: "pollutant_groups"
  """
  pollutant_groups(
    """distinct select on columns"""
    distinct_on: [pollutant_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutant_groups_order_by!]

    """filter the rows returned"""
    where: pollutant_groups_bool_exp
  ): [pollutant_groups!]!

  """
  fetch aggregated fields from the table: "pollutant_groups"
  """
  pollutant_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [pollutant_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutant_groups_order_by!]

    """filter the rows returned"""
    where: pollutant_groups_bool_exp
  ): pollutant_groups_aggregate!

  """
  fetch data from the table: "pollutant_groups" using primary key columns
  """
  pollutant_groups_by_pk(id: uuid!): pollutant_groups

  """
  fetch data from the table: "pollutants"
  """
  pollutants(
    """distinct select on columns"""
    distinct_on: [pollutants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutants_order_by!]

    """filter the rows returned"""
    where: pollutants_bool_exp
  ): [pollutants!]!

  """
  fetch aggregated fields from the table: "pollutants"
  """
  pollutants_aggregate(
    """distinct select on columns"""
    distinct_on: [pollutants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutants_order_by!]

    """filter the rows returned"""
    where: pollutants_bool_exp
  ): pollutants_aggregate!

  """fetch data from the table: "pollutants" using primary key columns"""
  pollutants_by_pk(id: uuid!): pollutants

  """
  fetch data from the table: "release_sources"
  """
  release_sources(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): [release_sources!]!

  """
  fetch aggregated fields from the table: "release_sources"
  """
  release_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): release_sources_aggregate!

  """fetch data from the table: "release_sources" using primary key columns"""
  release_sources_by_pk(id: uuid!): release_sources

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: Int!): roles

  """
  fetch data from the table: "states"
  """
  states(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): [states!]!

  """
  fetch aggregated fields from the table: "states"
  """
  states_aggregate(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): states_aggregate!

  """fetch data from the table: "states" using primary key columns"""
  states_by_pk(id: uuid!): states

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users

  """
  fetch data from the table: "worksite_categories"
  """
  worksite_categories(
    """distinct select on columns"""
    distinct_on: [worksite_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksite_categories_order_by!]

    """filter the rows returned"""
    where: worksite_categories_bool_exp
  ): [worksite_categories!]!

  """
  fetch aggregated fields from the table: "worksite_categories"
  """
  worksite_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [worksite_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksite_categories_order_by!]

    """filter the rows returned"""
    where: worksite_categories_bool_exp
  ): worksite_categories_aggregate!

  """
  fetch data from the table: "worksite_categories" using primary key columns
  """
  worksite_categories_by_pk(id: uuid!): worksite_categories

  """
  fetch data from the table: "worksites"
  """
  worksites(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): [worksites!]!

  """
  fetch aggregated fields from the table: "worksites"
  """
  worksites_aggregate(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): worksites_aggregate!

  """fetch data from the table: "worksites" using primary key columns"""
  worksites_by_pk(id: uuid!): worksites
}

"""
columns and relationships of "release_sources"
"""
type release_sources {
  created_at: timestamptz!

  """An object relationship"""
  emission_source: emission_sources
  emission_src_id: uuid!
  ghg_source: Boolean!
  id: uuid!
  inventory_number: String!
  name: String!
  number: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "release_sources"
"""
type release_sources_aggregate {
  aggregate: release_sources_aggregate_fields
  nodes: [release_sources!]!
}

"""
aggregate fields of "release_sources"
"""
type release_sources_aggregate_fields {
  count(columns: [release_sources_select_column!], distinct: Boolean): Int
  max: release_sources_max_fields
  min: release_sources_min_fields
}

"""
order by aggregate values of table "release_sources"
"""
input release_sources_aggregate_order_by {
  count: order_by
  max: release_sources_max_order_by
  min: release_sources_min_order_by
}

"""
input type for inserting array relation for remote table "release_sources"
"""
input release_sources_arr_rel_insert_input {
  data: [release_sources_insert_input!]!
  on_conflict: release_sources_on_conflict
}

"""
Boolean expression to filter rows from the table "release_sources". All fields are combined with a logical 'AND'.
"""
input release_sources_bool_exp {
  _and: [release_sources_bool_exp]
  _not: release_sources_bool_exp
  _or: [release_sources_bool_exp]
  created_at: timestamptz_comparison_exp
  emission_source: emission_sources_bool_exp
  emission_src_id: uuid_comparison_exp
  ghg_source: Boolean_comparison_exp
  id: uuid_comparison_exp
  inventory_number: String_comparison_exp
  name: String_comparison_exp
  number: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "release_sources"
"""
enum release_sources_constraint {
  """unique or primary key constraint"""
  release_sources_pkey
}

"""
input type for inserting data into table "release_sources"
"""
input release_sources_insert_input {
  created_at: timestamptz
  emission_source: emission_sources_obj_rel_insert_input
  emission_src_id: uuid
  ghg_source: Boolean
  id: uuid
  inventory_number: String
  name: String
  number: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type release_sources_max_fields {
  created_at: timestamptz
  emission_src_id: uuid
  id: uuid
  inventory_number: String
  name: String
  number: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "release_sources"
"""
input release_sources_max_order_by {
  created_at: order_by
  emission_src_id: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type release_sources_min_fields {
  created_at: timestamptz
  emission_src_id: uuid
  id: uuid
  inventory_number: String
  name: String
  number: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "release_sources"
"""
input release_sources_min_order_by {
  created_at: order_by
  emission_src_id: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "release_sources"
"""
type release_sources_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [release_sources!]!
}

"""
input type for inserting object relation for remote table "release_sources"
"""
input release_sources_obj_rel_insert_input {
  data: release_sources_insert_input!
  on_conflict: release_sources_on_conflict
}

"""
on conflict condition type for table "release_sources"
"""
input release_sources_on_conflict {
  constraint: release_sources_constraint!
  update_columns: [release_sources_update_column!]!
  where: release_sources_bool_exp
}

"""
ordering options when selecting data from "release_sources"
"""
input release_sources_order_by {
  created_at: order_by
  emission_source: emission_sources_order_by
  emission_src_id: order_by
  ghg_source: order_by
  id: order_by
  inventory_number: order_by
  name: order_by
  number: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "release_sources"
"""
input release_sources_pk_columns_input {
  id: uuid!
}

"""
select columns of table "release_sources"
"""
enum release_sources_select_column {
  """column name"""
  created_at

  """column name"""
  emission_src_id

  """column name"""
  ghg_source

  """column name"""
  id

  """column name"""
  inventory_number

  """column name"""
  name

  """column name"""
  number

  """column name"""
  updated_at
}

"""
input type for updating data in table "release_sources"
"""
input release_sources_set_input {
  created_at: timestamptz
  emission_src_id: uuid
  ghg_source: Boolean
  id: uuid
  inventory_number: String
  name: String
  number: String
  updated_at: timestamptz
}

"""
update columns of table "release_sources"
"""
enum release_sources_update_column {
  """column name"""
  created_at

  """column name"""
  emission_src_id

  """column name"""
  ghg_source

  """column name"""
  id

  """column name"""
  inventory_number

  """column name"""
  name

  """column name"""
  number

  """column name"""
  updated_at
}

"""
columns and relationships of "roles"
"""
type roles {
  createdAt: timestamptz!
  description: String
  id: Int!
  name: String!
  updatedAt: timestamptz!
  value: String!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  avg: roles_avg_fields
  count(columns: [roles_select_column!], distinct: Boolean): Int
  max: roles_max_fields
  min: roles_min_fields
  stddev: roles_stddev_fields
  stddev_pop: roles_stddev_pop_fields
  stddev_samp: roles_stddev_samp_fields
  sum: roles_sum_fields
  var_pop: roles_var_pop_fields
  var_samp: roles_var_samp_fields
  variance: roles_variance_fields
}

"""
order by aggregate values of table "roles"
"""
input roles_aggregate_order_by {
  avg: roles_avg_order_by
  count: order_by
  max: roles_max_order_by
  min: roles_min_order_by
  stddev: roles_stddev_order_by
  stddev_pop: roles_stddev_pop_order_by
  stddev_samp: roles_stddev_samp_order_by
  sum: roles_sum_order_by
  var_pop: roles_var_pop_order_by
  var_samp: roles_var_samp_order_by
  variance: roles_variance_order_by
}

"""
input type for inserting array relation for remote table "roles"
"""
input roles_arr_rel_insert_input {
  data: [roles_insert_input!]!
  on_conflict: roles_on_conflict
}

"""aggregate avg on columns"""
type roles_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "roles"
"""
input roles_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp]
  _not: roles_bool_exp
  _or: [roles_bool_exp]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """unique or primary key constraint"""
  roles_pkey

  """unique or primary key constraint"""
  roles_value_key
}

"""
input type for incrementing integer column in table "roles"
"""
input roles_inc_input {
  id: Int
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  createdAt: timestamptz
  description: String
  id: Int
  name: String
  updatedAt: timestamptz
  value: String
}

"""aggregate max on columns"""
type roles_max_fields {
  createdAt: timestamptz
  description: String
  id: Int
  name: String
  updatedAt: timestamptz
  value: String
}

"""
order by max() on columns of table "roles"
"""
input roles_max_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
  value: order_by
}

"""aggregate min on columns"""
type roles_min_fields {
  createdAt: timestamptz
  description: String
  id: Int
  name: String
  updatedAt: timestamptz
  value: String
}

"""
order by min() on columns of table "roles"
"""
input roles_min_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
  value: order_by
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!
  on_conflict: roles_on_conflict
}

"""
on conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]!
  where: roles_bool_exp
}

"""
ordering options when selecting data from "roles"
"""
input roles_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
  value: order_by
}

"""
primary key columns input for table: "roles"
"""
input roles_pk_columns_input {
  id: Int!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  createdAt: timestamptz
  description: String
  id: Int
  name: String
  updatedAt: timestamptz
  value: String
}

"""aggregate stddev on columns"""
type roles_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "roles"
"""
input roles_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type roles_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "roles"
"""
input roles_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type roles_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "roles"
"""
input roles_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type roles_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "roles"
"""
input roles_sum_order_by {
  id: order_by
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type roles_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "roles"
"""
input roles_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type roles_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "roles"
"""
input roles_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type roles_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "roles"
"""
input roles_variance_order_by {
  id: order_by
}

type signupOutput {
  id: uuid!
  roles: [String!]
  token: String!
}

"""
columns and relationships of "states"
"""
type states {
  """An array relationship"""
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """An aggregated array relationship"""
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """An object relationship"""
  country: countries!
  country_id: uuid!
  id: uuid!
  name: String!
}

"""
aggregated selection of "states"
"""
type states_aggregate {
  aggregate: states_aggregate_fields
  nodes: [states!]!
}

"""
aggregate fields of "states"
"""
type states_aggregate_fields {
  count(columns: [states_select_column!], distinct: Boolean): Int
  max: states_max_fields
  min: states_min_fields
}

"""
order by aggregate values of table "states"
"""
input states_aggregate_order_by {
  count: order_by
  max: states_max_order_by
  min: states_min_order_by
}

"""
input type for inserting array relation for remote table "states"
"""
input states_arr_rel_insert_input {
  data: [states_insert_input!]!
  on_conflict: states_on_conflict
}

"""
Boolean expression to filter rows from the table "states". All fields are combined with a logical 'AND'.
"""
input states_bool_exp {
  _and: [states_bool_exp]
  _not: states_bool_exp
  _or: [states_bool_exp]
  cities: cities_bool_exp
  country: countries_bool_exp
  country_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "states"
"""
enum states_constraint {
  """unique or primary key constraint"""
  states_name_key

  """unique or primary key constraint"""
  states_pkey
}

"""
input type for inserting data into table "states"
"""
input states_insert_input {
  cities: cities_arr_rel_insert_input
  country: countries_obj_rel_insert_input
  country_id: uuid
  id: uuid
  name: String
}

"""aggregate max on columns"""
type states_max_fields {
  country_id: uuid
  id: uuid
  name: String
}

"""
order by max() on columns of table "states"
"""
input states_max_order_by {
  country_id: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type states_min_fields {
  country_id: uuid
  id: uuid
  name: String
}

"""
order by min() on columns of table "states"
"""
input states_min_order_by {
  country_id: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "states"
"""
type states_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [states!]!
}

"""
input type for inserting object relation for remote table "states"
"""
input states_obj_rel_insert_input {
  data: states_insert_input!
  on_conflict: states_on_conflict
}

"""
on conflict condition type for table "states"
"""
input states_on_conflict {
  constraint: states_constraint!
  update_columns: [states_update_column!]!
  where: states_bool_exp
}

"""
ordering options when selecting data from "states"
"""
input states_order_by {
  cities_aggregate: cities_aggregate_order_by
  country: countries_order_by
  country_id: order_by
  id: order_by
  name: order_by
}

"""
primary key columns input for table: "states"
"""
input states_pk_columns_input {
  id: uuid!
}

"""
select columns of table "states"
"""
enum states_select_column {
  """column name"""
  country_id

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "states"
"""
input states_set_input {
  country_id: uuid
  id: uuid
  name: String
}

"""
update columns of table "states"
"""
enum states_update_column {
  """column name"""
  country_id

  """column name"""
  id

  """column name"""
  name
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "bank_accounts"
  """
  bank_accounts(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): [bank_accounts!]!

  """
  fetch aggregated fields from the table: "bank_accounts"
  """
  bank_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [bank_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bank_accounts_order_by!]

    """filter the rows returned"""
    where: bank_accounts_bool_exp
  ): bank_accounts_aggregate!

  """fetch data from the table: "bank_accounts" using primary key columns"""
  bank_accounts_by_pk(id: uuid!): bank_accounts

  """
  fetch data from the table: "banks"
  """
  banks(
    """distinct select on columns"""
    distinct_on: [banks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [banks_order_by!]

    """filter the rows returned"""
    where: banks_bool_exp
  ): [banks!]!

  """
  fetch aggregated fields from the table: "banks"
  """
  banks_aggregate(
    """distinct select on columns"""
    distinct_on: [banks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [banks_order_by!]

    """filter the rows returned"""
    where: banks_bool_exp
  ): banks_aggregate!

  """fetch data from the table: "banks" using primary key columns"""
  banks_by_pk(id: uuid!): banks

  """
  fetch data from the table: "cities"
  """
  cities(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): [cities!]!

  """
  fetch aggregated fields from the table: "cities"
  """
  cities_aggregate(
    """distinct select on columns"""
    distinct_on: [cities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cities_order_by!]

    """filter the rows returned"""
    where: cities_bool_exp
  ): cities_aggregate!

  """fetch data from the table: "cities" using primary key columns"""
  cities_by_pk(id: uuid!): cities

  """
  fetch data from the table: "companies"
  """
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """
  fetch aggregated fields from the table: "companies"
  """
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table: "company_addresses"
  """
  company_addresses(
    """distinct select on columns"""
    distinct_on: [company_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_addresses_order_by!]

    """filter the rows returned"""
    where: company_addresses_bool_exp
  ): [company_addresses!]!

  """
  fetch aggregated fields from the table: "company_addresses"
  """
  company_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [company_addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_addresses_order_by!]

    """filter the rows returned"""
    where: company_addresses_bool_exp
  ): company_addresses_aggregate!

  """
  fetch data from the table: "company_addresses" using primary key columns
  """
  company_addresses_by_pk(id: uuid!): company_addresses

  """
  fetch data from the table: "company_departments"
  """
  company_departments(
    """distinct select on columns"""
    distinct_on: [company_departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_departments_order_by!]

    """filter the rows returned"""
    where: company_departments_bool_exp
  ): [company_departments!]!

  """
  fetch aggregated fields from the table: "company_departments"
  """
  company_departments_aggregate(
    """distinct select on columns"""
    distinct_on: [company_departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_departments_order_by!]

    """filter the rows returned"""
    where: company_departments_bool_exp
  ): company_departments_aggregate!

  """
  fetch data from the table: "company_departments" using primary key columns
  """
  company_departments_by_pk(id: uuid!): company_departments

  """
  fetch data from the table: "company_types"
  """
  company_types(
    """distinct select on columns"""
    distinct_on: [company_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_types_order_by!]

    """filter the rows returned"""
    where: company_types_bool_exp
  ): [company_types!]!

  """
  fetch aggregated fields from the table: "company_types"
  """
  company_types_aggregate(
    """distinct select on columns"""
    distinct_on: [company_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_types_order_by!]

    """filter the rows returned"""
    where: company_types_bool_exp
  ): company_types_aggregate!

  """fetch data from the table: "company_types" using primary key columns"""
  company_types_by_pk(id: uuid!): company_types

  """
  fetch data from the table: "countries"
  """
  countries(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): [countries!]!

  """
  fetch aggregated fields from the table: "countries"
  """
  countries_aggregate(
    """distinct select on columns"""
    distinct_on: [countries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [countries_order_by!]

    """filter the rows returned"""
    where: countries_bool_exp
  ): countries_aggregate!

  """fetch data from the table: "countries" using primary key columns"""
  countries_by_pk(id: uuid!): countries

  """
  fetch data from the table: "currencies"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): [currencies!]!

  """
  fetch aggregated fields from the table: "currencies"
  """
  currencies_aggregate(
    """distinct select on columns"""
    distinct_on: [currencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currencies_order_by!]

    """filter the rows returned"""
    where: currencies_bool_exp
  ): currencies_aggregate!

  """fetch data from the table: "currencies" using primary key columns"""
  currencies_by_pk(id: uuid!): currencies

  """
  fetch data from the table: "emission_sources"
  """
  emission_sources(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): [emission_sources!]!

  """
  fetch aggregated fields from the table: "emission_sources"
  """
  emission_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [emission_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [emission_sources_order_by!]

    """filter the rows returned"""
    where: emission_sources_bool_exp
  ): emission_sources_aggregate!

  """
  fetch data from the table: "emission_sources" using primary key columns
  """
  emission_sources_by_pk(id: uuid!): emission_sources

  """
  fetch data from the table: "employee_positions"
  """
  employee_positions(
    """distinct select on columns"""
    distinct_on: [employee_positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_positions_order_by!]

    """filter the rows returned"""
    where: employee_positions_bool_exp
  ): [employee_positions!]!

  """
  fetch aggregated fields from the table: "employee_positions"
  """
  employee_positions_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_positions_order_by!]

    """filter the rows returned"""
    where: employee_positions_bool_exp
  ): employee_positions_aggregate!

  """
  fetch data from the table: "employee_positions" using primary key columns
  """
  employee_positions_by_pk(id: uuid!): employee_positions

  """
  fetch data from the table: "employees"
  """
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch aggregated fields from the table: "employees"
  """
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table: "facilities"
  """
  facilities(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): [facilities!]!

  """
  fetch aggregated fields from the table: "facilities"
  """
  facilities_aggregate(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): facilities_aggregate!

  """fetch data from the table: "facilities" using primary key columns"""
  facilities_by_pk(id: uuid!): facilities

  """
  fetch data from the table: "facility_locations"
  """
  facility_locations(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): [facility_locations!]!

  """
  fetch aggregated fields from the table: "facility_locations"
  """
  facility_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [facility_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facility_locations_order_by!]

    """filter the rows returned"""
    where: facility_locations_bool_exp
  ): facility_locations_aggregate!

  """
  fetch data from the table: "facility_locations" using primary key columns
  """
  facility_locations_by_pk(id: uuid!): facility_locations

  """
  fetch data from the table: "filter_equipments"
  """
  filter_equipments(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): [filter_equipments!]!

  """
  fetch aggregated fields from the table: "filter_equipments"
  """
  filter_equipments_aggregate(
    """distinct select on columns"""
    distinct_on: [filter_equipments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [filter_equipments_order_by!]

    """filter the rows returned"""
    where: filter_equipments_bool_exp
  ): filter_equipments_aggregate!

  """
  fetch data from the table: "filter_equipments" using primary key columns
  """
  filter_equipments_by_pk(id: uuid!): filter_equipments

  """
  fetch data from the table: "limit_permissions"
  """
  limit_permissions(
    """distinct select on columns"""
    distinct_on: [limit_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [limit_permissions_order_by!]

    """filter the rows returned"""
    where: limit_permissions_bool_exp
  ): [limit_permissions!]!

  """
  fetch aggregated fields from the table: "limit_permissions"
  """
  limit_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [limit_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [limit_permissions_order_by!]

    """filter the rows returned"""
    where: limit_permissions_bool_exp
  ): limit_permissions_aggregate!

  """
  fetch data from the table: "limit_permissions" using primary key columns
  """
  limit_permissions_by_pk(id: uuid!): limit_permissions

  """
  fetch data from the table: "permission_pol_groups"
  """
  permission_pol_groups(
    """distinct select on columns"""
    distinct_on: [permission_pol_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_pol_groups_order_by!]

    """filter the rows returned"""
    where: permission_pol_groups_bool_exp
  ): [permission_pol_groups!]!

  """
  fetch aggregated fields from the table: "permission_pol_groups"
  """
  permission_pol_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_pol_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_pol_groups_order_by!]

    """filter the rows returned"""
    where: permission_pol_groups_bool_exp
  ): permission_pol_groups_aggregate!

  """
  fetch data from the table: "permission_pol_groups" using primary key columns
  """
  permission_pol_groups_by_pk(id: uuid!): permission_pol_groups

  """
  fetch data from the table: "pollutant_groups"
  """
  pollutant_groups(
    """distinct select on columns"""
    distinct_on: [pollutant_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutant_groups_order_by!]

    """filter the rows returned"""
    where: pollutant_groups_bool_exp
  ): [pollutant_groups!]!

  """
  fetch aggregated fields from the table: "pollutant_groups"
  """
  pollutant_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [pollutant_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutant_groups_order_by!]

    """filter the rows returned"""
    where: pollutant_groups_bool_exp
  ): pollutant_groups_aggregate!

  """
  fetch data from the table: "pollutant_groups" using primary key columns
  """
  pollutant_groups_by_pk(id: uuid!): pollutant_groups

  """
  fetch data from the table: "pollutants"
  """
  pollutants(
    """distinct select on columns"""
    distinct_on: [pollutants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutants_order_by!]

    """filter the rows returned"""
    where: pollutants_bool_exp
  ): [pollutants!]!

  """
  fetch aggregated fields from the table: "pollutants"
  """
  pollutants_aggregate(
    """distinct select on columns"""
    distinct_on: [pollutants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pollutants_order_by!]

    """filter the rows returned"""
    where: pollutants_bool_exp
  ): pollutants_aggregate!

  """fetch data from the table: "pollutants" using primary key columns"""
  pollutants_by_pk(id: uuid!): pollutants

  """
  fetch data from the table: "release_sources"
  """
  release_sources(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): [release_sources!]!

  """
  fetch aggregated fields from the table: "release_sources"
  """
  release_sources_aggregate(
    """distinct select on columns"""
    distinct_on: [release_sources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [release_sources_order_by!]

    """filter the rows returned"""
    where: release_sources_bool_exp
  ): release_sources_aggregate!

  """fetch data from the table: "release_sources" using primary key columns"""
  release_sources_by_pk(id: uuid!): release_sources

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: Int!): roles

  """
  fetch data from the table: "states"
  """
  states(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): [states!]!

  """
  fetch aggregated fields from the table: "states"
  """
  states_aggregate(
    """distinct select on columns"""
    distinct_on: [states_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [states_order_by!]

    """filter the rows returned"""
    where: states_bool_exp
  ): states_aggregate!

  """fetch data from the table: "states" using primary key columns"""
  states_by_pk(id: uuid!): states

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users

  """
  fetch data from the table: "worksite_categories"
  """
  worksite_categories(
    """distinct select on columns"""
    distinct_on: [worksite_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksite_categories_order_by!]

    """filter the rows returned"""
    where: worksite_categories_bool_exp
  ): [worksite_categories!]!

  """
  fetch aggregated fields from the table: "worksite_categories"
  """
  worksite_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [worksite_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksite_categories_order_by!]

    """filter the rows returned"""
    where: worksite_categories_bool_exp
  ): worksite_categories_aggregate!

  """
  fetch data from the table: "worksite_categories" using primary key columns
  """
  worksite_categories_by_pk(id: uuid!): worksite_categories

  """
  fetch data from the table: "worksites"
  """
  worksites(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): [worksites!]!

  """
  fetch aggregated fields from the table: "worksites"
  """
  worksites_aggregate(
    """distinct select on columns"""
    distinct_on: [worksites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [worksites_order_by!]

    """filter the rows returned"""
    where: worksites_bool_exp
  ): worksites_aggregate!

  """fetch data from the table: "worksites" using primary key columns"""
  worksites_by_pk(id: uuid!): worksites
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "users"
"""
type users {
  active: Boolean!
  createdAt: timestamptz!
  email: String!

  """An object relationship"""
  employee: employees
  id: Int!
  password: String!

  """An object relationship"""
  role: roles
  roleId: Int
  updatedAt: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  avg: users_avg_order_by
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
  stddev: users_stddev_order_by
  stddev_pop: users_stddev_pop_order_by
  stddev_samp: users_stddev_samp_order_by
  sum: users_sum_order_by
  var_pop: users_var_pop_order_by
  var_samp: users_var_samp_order_by
  variance: users_variance_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""aggregate avg on columns"""
type users_avg_fields {
  id: Float
  roleId: Float
}

"""
order by avg() on columns of table "users"
"""
input users_avg_order_by {
  id: order_by
  roleId: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  active: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  employee: employees_bool_exp
  id: Int_comparison_exp
  password: String_comparison_exp
  role: roles_bool_exp
  roleId: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_email_key

  """unique or primary key constraint"""
  users_pkey
}

"""
input type for incrementing integer column in table "users"
"""
input users_inc_input {
  id: Int
  roleId: Int
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  active: Boolean
  createdAt: timestamptz
  email: String
  employee: employees_obj_rel_insert_input
  id: Int
  password: String
  role: roles_obj_rel_insert_input
  roleId: Int
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  createdAt: timestamptz
  email: String
  id: Int
  password: String
  roleId: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  createdAt: order_by
  email: order_by
  id: order_by
  password: order_by
  roleId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  createdAt: timestamptz
  email: String
  id: Int
  password: String
  roleId: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  createdAt: order_by
  email: order_by
  id: order_by
  password: order_by
  roleId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  active: order_by
  createdAt: order_by
  email: order_by
  employee: employees_order_by
  id: order_by
  password: order_by
  role: roles_order_by
  roleId: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "users"
"""
input users_pk_columns_input {
  id: Int!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  password

  """column name"""
  roleId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  active: Boolean
  createdAt: timestamptz
  email: String
  id: Int
  password: String
  roleId: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type users_stddev_fields {
  id: Float
  roleId: Float
}

"""
order by stddev() on columns of table "users"
"""
input users_stddev_order_by {
  id: order_by
  roleId: order_by
}

"""aggregate stddev_pop on columns"""
type users_stddev_pop_fields {
  id: Float
  roleId: Float
}

"""
order by stddev_pop() on columns of table "users"
"""
input users_stddev_pop_order_by {
  id: order_by
  roleId: order_by
}

"""aggregate stddev_samp on columns"""
type users_stddev_samp_fields {
  id: Float
  roleId: Float
}

"""
order by stddev_samp() on columns of table "users"
"""
input users_stddev_samp_order_by {
  id: order_by
  roleId: order_by
}

"""aggregate sum on columns"""
type users_sum_fields {
  id: Int
  roleId: Int
}

"""
order by sum() on columns of table "users"
"""
input users_sum_order_by {
  id: order_by
  roleId: order_by
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  password

  """column name"""
  roleId

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type users_var_pop_fields {
  id: Float
  roleId: Float
}

"""
order by var_pop() on columns of table "users"
"""
input users_var_pop_order_by {
  id: order_by
  roleId: order_by
}

"""aggregate var_samp on columns"""
type users_var_samp_fields {
  id: Float
  roleId: Float
}

"""
order by var_samp() on columns of table "users"
"""
input users_var_samp_order_by {
  id: order_by
  roleId: order_by
}

"""aggregate variance on columns"""
type users_variance_fields {
  id: Float
  roleId: Float
}

"""
order by variance() on columns of table "users"
"""
input users_variance_order_by {
  id: order_by
  roleId: order_by
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "worksite_categories"
"""
type worksite_categories {
  id: uuid!
  name: String!
}

"""
aggregated selection of "worksite_categories"
"""
type worksite_categories_aggregate {
  aggregate: worksite_categories_aggregate_fields
  nodes: [worksite_categories!]!
}

"""
aggregate fields of "worksite_categories"
"""
type worksite_categories_aggregate_fields {
  count(columns: [worksite_categories_select_column!], distinct: Boolean): Int
  max: worksite_categories_max_fields
  min: worksite_categories_min_fields
}

"""
order by aggregate values of table "worksite_categories"
"""
input worksite_categories_aggregate_order_by {
  count: order_by
  max: worksite_categories_max_order_by
  min: worksite_categories_min_order_by
}

"""
input type for inserting array relation for remote table "worksite_categories"
"""
input worksite_categories_arr_rel_insert_input {
  data: [worksite_categories_insert_input!]!
  on_conflict: worksite_categories_on_conflict
}

"""
Boolean expression to filter rows from the table "worksite_categories". All fields are combined with a logical 'AND'.
"""
input worksite_categories_bool_exp {
  _and: [worksite_categories_bool_exp]
  _not: worksite_categories_bool_exp
  _or: [worksite_categories_bool_exp]
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "worksite_categories"
"""
enum worksite_categories_constraint {
  """unique or primary key constraint"""
  worksite_categories_pkey
}

"""
input type for inserting data into table "worksite_categories"
"""
input worksite_categories_insert_input {
  id: uuid
  name: String
}

"""aggregate max on columns"""
type worksite_categories_max_fields {
  id: uuid
  name: String
}

"""
order by max() on columns of table "worksite_categories"
"""
input worksite_categories_max_order_by {
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type worksite_categories_min_fields {
  id: uuid
  name: String
}

"""
order by min() on columns of table "worksite_categories"
"""
input worksite_categories_min_order_by {
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "worksite_categories"
"""
type worksite_categories_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [worksite_categories!]!
}

"""
input type for inserting object relation for remote table "worksite_categories"
"""
input worksite_categories_obj_rel_insert_input {
  data: worksite_categories_insert_input!
  on_conflict: worksite_categories_on_conflict
}

"""
on conflict condition type for table "worksite_categories"
"""
input worksite_categories_on_conflict {
  constraint: worksite_categories_constraint!
  update_columns: [worksite_categories_update_column!]!
  where: worksite_categories_bool_exp
}

"""
ordering options when selecting data from "worksite_categories"
"""
input worksite_categories_order_by {
  id: order_by
  name: order_by
}

"""
primary key columns input for table: "worksite_categories"
"""
input worksite_categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "worksite_categories"
"""
enum worksite_categories_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "worksite_categories"
"""
input worksite_categories_set_input {
  id: uuid
  name: String
}

"""
update columns of table "worksite_categories"
"""
enum worksite_categories_update_column {
  """column name"""
  id

  """column name"""
  name
}

"""
columns and relationships of "worksites"
"""
type worksites {
  category_id: uuid!

  """An object relationship"""
  company: companies
  company_id: uuid!
  created_at: timestamptz!

  """An array relationship"""
  facilities(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): [facilities!]!

  """An aggregated array relationship"""
  facilities_aggregate(
    """distinct select on columns"""
    distinct_on: [facilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [facilities_order_by!]

    """filter the rows returned"""
    where: facilities_bool_exp
  ): facilities_aggregate!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "worksites"
"""
type worksites_aggregate {
  aggregate: worksites_aggregate_fields
  nodes: [worksites!]!
}

"""
aggregate fields of "worksites"
"""
type worksites_aggregate_fields {
  count(columns: [worksites_select_column!], distinct: Boolean): Int
  max: worksites_max_fields
  min: worksites_min_fields
}

"""
order by aggregate values of table "worksites"
"""
input worksites_aggregate_order_by {
  count: order_by
  max: worksites_max_order_by
  min: worksites_min_order_by
}

"""
input type for inserting array relation for remote table "worksites"
"""
input worksites_arr_rel_insert_input {
  data: [worksites_insert_input!]!
  on_conflict: worksites_on_conflict
}

"""
Boolean expression to filter rows from the table "worksites". All fields are combined with a logical 'AND'.
"""
input worksites_bool_exp {
  _and: [worksites_bool_exp]
  _not: worksites_bool_exp
  _or: [worksites_bool_exp]
  category_id: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  facilities: facilities_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "worksites"
"""
enum worksites_constraint {
  """unique or primary key constraint"""
  worksites_pkey
}

"""
input type for inserting data into table "worksites"
"""
input worksites_insert_input {
  category_id: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  facilities: facilities_arr_rel_insert_input
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type worksites_max_fields {
  category_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "worksites"
"""
input worksites_max_order_by {
  category_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type worksites_min_fields {
  category_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "worksites"
"""
input worksites_min_order_by {
  category_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "worksites"
"""
type worksites_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [worksites!]!
}

"""
input type for inserting object relation for remote table "worksites"
"""
input worksites_obj_rel_insert_input {
  data: worksites_insert_input!
  on_conflict: worksites_on_conflict
}

"""
on conflict condition type for table "worksites"
"""
input worksites_on_conflict {
  constraint: worksites_constraint!
  update_columns: [worksites_update_column!]!
  where: worksites_bool_exp
}

"""
ordering options when selecting data from "worksites"
"""
input worksites_order_by {
  category_id: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  facilities_aggregate: facilities_aggregate_order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "worksites"
"""
input worksites_pk_columns_input {
  id: uuid!
}

"""
select columns of table "worksites"
"""
enum worksites_select_column {
  """column name"""
  category_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "worksites"
"""
input worksites_set_input {
  category_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "worksites"
"""
enum worksites_update_column {
  """column name"""
  category_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

